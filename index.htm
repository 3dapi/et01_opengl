<?php
	include '../base/lc_header.php';
	include '../base/lc_util.php';
?>

<!--------------------------- Body Begin ---------------------------------------->

<div class="Section1">

<br>
<h1>◈11 OpenGL Programming◈</h1>

<p class=MsoNormal><span lang=EN-US>DirectX 8.0</span>까지<span lang=EN-US>
OpenGL</span>과<span lang=EN-US> Direct3D</span>는 한 때 비슷한 성능으로 경쟁 관계에 있다가<span
lang=EN-US> DirectX 9.0, 10, 11</span>이후에 개인용 컴퓨터 게임 제작에서 잘 사용이 안되다가 <span
lang=EN-US>Embedded </span>환경에서 다시 <span lang=EN-US>3D </span>표준 라이브러리로 정착되는 되고
있습니다<span lang=EN-US>. </span>특히<span lang=EN-US> OpenGL ES 2.0(OpenGL Embedded
System) </span>버전부터 쉐이더가 지원이 되어 모바일에서도<span lang=EN-US> PC</span>에서 사용한 쉐이더를 조금
수정해서 쉽게 적용할 수 있는 장점이 있어 앞으로 많이 주목되고 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&quot;</span>난 개인용 컴퓨터나<span lang=EN-US>
XBOX</span>에서만 게임을 만들 꺼야<span lang=EN-US>.&quot; </span>라고 결심을 굳히신 분들도<span
lang=EN-US> OpenGL</span>을 공부해보라고 권하고 싶습니다<span lang=EN-US>. </span>이러한 이유는 첫 번째로<span
lang=EN-US> OpenGL</span>을 잘 알고 있으면<span lang=EN-US> D3D</span>의 이해가 빠릅니다<span
lang=EN-US>. </span>혹자는<span lang=EN-US> D3D</span>의 그래픽 파이프라인은<span
lang=EN-US> OpenGL</span>을 베껴서 만들었다고 비평하는 분들도 있는데 이것은<span lang=EN-US> D3D</span>의
많은 개념들이 이름만 바꾸면<span lang=EN-US> OpenGL</span>의 개념과 일치하는 부분이 많고<span
lang=EN-US> 3D </span>데이터를 처리하는 절차가 <span lang=EN-US>OpenGL</span>과 상당히 유사하기 때문입니다<span
lang=EN-US>. </span>지금까지 대다수의 그래픽 이론과 기술들이<span lang=EN-US> OpenGL</span>기반으로 작성된
것이 많습니다<span lang=EN-US>. </span>만약 여러분들이 중견 프로그래머가 되면 출간된 책보다는 학회지 또는 논문들을 통해서
이론과 기술들을 배울 때가 있는데 이 때<span lang=EN-US> OpenGL</span>을 알고 있는 것이 상당히 도움이 됩니다<span
lang=EN-US>. </span>이렇게<span lang=EN-US> OpenGL</span>은 <span lang=EN-US>D3D</span>를
공부하는데 끊어진 지식의 연결 고리를 이어주고 채우지 못한 빈 공간을 메워 줄 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>두 번째로 <span lang=EN-US>OpenGL</span>은 거의 모든 운영 체제에서 지원이 되고 이식성<span
lang=EN-US>(Portability) </span>또한 뛰어 나서 한 번 만든 코드는 다른 플랫폼에서도 거의 변경 없이 사용할 수 있습니다<span
lang=EN-US>. </span>특히<span lang=EN-US> Embedded </span>환경에서 게임을 제작을 하려면 개인용 컴퓨터에서
만들고 다음으로 모바일에 이식하는 것이 보통입니다<span lang=EN-US>. </span>이런 방식의 작업에서<span
lang=EN-US> OpenGL</span>은 상당히 장점이 많이 있습니다<span lang=EN-US>. </span>모바일에서 <span
lang=EN-US>DirectMobile3D</span>가 있지만<span lang=EN-US> Windows </span>시스템에만 지원이
되고 있습니다<span lang=EN-US>. </span>현재 <span lang=EN-US>NDS(Nintendo DS), iPhone </span>등에서<span
lang=EN-US> 3D </span>게임은<span lang=EN-US> OpenGL ES</span>로 개발하고 있으며<span
lang=EN-US>, </span>국산 게임기<span lang=EN-US> Wiz(</span>게임파크홀딩스<span lang=EN-US>)</span>도
<span lang=EN-US>OpenGL</span>을 지원하고 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>수 많은 대한민국의 게임 개발사들이 전부<span lang=EN-US> Direct3D </span>기반으로
게임을 제작하고 있어서 취업에<span lang=EN-US> OpenGL</span>이 별 도움이 안될 것이란 생각이 있더라도 이렇게 멋진 그래픽
<span lang=EN-US>API</span>를 한 번도 만져보지 못했다면<span lang=EN-US> 3D </span>게임 프로그래머로서
불행이라 여기고 꼭<span lang=EN-US>, </span>해보기 바랍니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>말이 좀 길어졌는데 이 장에서는<span lang=EN-US> OpenGL</span>의 모든 내용을 전부 설명하기
보다는 그 동안 우리가 공부한<span lang=EN-US> D3D </span>순서에 맞추어 필요한 내용만 간추려서 살펴보겠습니다<span
lang=EN-US>. </span>먼저 개인용 컴퓨터에서<span lang=EN-US> OpenGL</span>을 활용해 보고 다음으로 <span
lang=EN-US>AMD</span>사에서 만든<span lang=EN-US> OpenGL ES Emulator</span>를 이용해서 <span
lang=EN-US>Embedded </span>환경에서의 프로그램 방법을 알아보겠습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:16.0pt'>11.1 OpenGL</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:14.0pt'>11.1.1 Rendering
Context (RC)</span></p>

<p class=MsoNormal><span lang=EN-US>D3D</span>의 디바이스에 대한 역할에 해당하는 것이<span
lang=EN-US> OpenGL</span>의<span lang=EN-US> Rendering Context(RC: </span>렌더링 문맥<span
lang=EN-US>)</span>입니다<span lang=EN-US>. </span>이 <span lang=EN-US>RC</span>는 <span
lang=EN-US>3D </span>렌더링 머신 또는 처리에 대한 모든 것으로 그래픽을 처리하는 <span lang=EN-US>Device
Context(DC: </span>장치 문맥<span lang=EN-US>)</span>을 대신해서 렌더링을 담당합니다<span
lang=EN-US>. RC</span>의 생성 방법은 운영 체제마다 다르지만 이 <span lang=EN-US>RC </span>안에서 <span
lang=EN-US>3D </span>그래픽 처리에 대한 모든 과정과 프로그래머가 렌더링 머신의 상태를 설정하거나 데이터를 전달하는 모든 방법은
동일합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>윈도우 시스템에서 이 <span lang=EN-US>RC</span>를 만들기 위해서<span
lang=EN-US> wgl(</span>읽을 때 위글<span lang=EN-US>: wiggle) </span>함수를 이용합니다<span
lang=EN-US>. RC</span>에 대한 위글 함수는 <span lang=EN-US>RC</span>를 생성하는<span
lang=EN-US> wglCreateContext(), RC</span>를 해제하는<span lang=EN-US>
wglDeleteContext(), </span>윈도우의<span lang=EN-US> DC</span>에 <span lang=EN-US>RC</span>를
설정하는<span lang=EN-US> wglMakeCurrent() </span>함수가 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>하나의 <span lang=EN-US>DC</span>는 여러 <span lang=EN-US>RC</span>를
둘 수 있고 <span lang=EN-US>DC</span>는 이들 <span lang=EN-US>RC </span>중에서 하나를 선택해 그래픽
처리를 맡기게 됩니다<span lang=EN-US>. </span>이것은 하나의 프로세스 안에서 여러 쓰레드를 이용해 렌더링 하는 것도 가능하다는
것입니다<span lang=EN-US>. </span>하지만 보통 게임 프로그램에서 <span lang=EN-US>RC</span>는 하나만 만들며
<span lang=EN-US>RC</span>를 생성과 동시에 <span lang=EN-US>DC</span>에<span
lang=EN-US> wglMakeCurrent() </span>함수를 이용해서 지정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>RC</span>의 생성<span lang=EN-US>, </span>렌더링<span
lang=EN-US>, </span>그리고 해제에 대한 순서를 정리하면 다음과 같습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>1. </span>여러분은 <span lang=EN-US>RegisterClass(),
CreateWindow() </span>함수를 이용해서 윈도우를 생성하고 생성된 윈도우에서 <span lang=EN-US>GetDC() </span>함수를
이용해 <span lang=EN-US>DC</span>를 얻어옵니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>2. RC</span>를 만들기 전에 여러분이 렌더링에 필요한 픽셀 형식에 가장
근접한 것을<span lang=EN-US> DC</span>에서 찾습니다<span lang=EN-US>. </span></p>

<p class=MsoNormal><span lang=EN-US>3. </span>픽셀 형식을<span lang=EN-US> DC</span>에
설정하고 <span lang=EN-US>RC</span>를 만듭니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>4. OpenGL </span>함수들을 이용해서 렌더링을 구현합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>5. </span>프로그램의 종료는 <span lang=EN-US>RC </span>해제<span
lang=EN-US>, DC </span>해제<span lang=EN-US>, </span>윈도우 해제 순으로 합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl01_device.zip">gl01_device.zip</a></span>은
<span lang=EN-US>RC</span>의 생성<span lang=EN-US>/</span>렌더링<span lang=EN-US>/</span>해제에
대한 예입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>먼저<span lang=EN-US> OpenGL</span>을 사용하기 위한 라이브러리와 헤더 파일을 다음과
같이 추가합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>#pragma comment</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>lib</span><span lang=EN-US>, </span><span
lang=EN-US style='color:fuchsia'>&quot;OpenGL32.Lib&quot;</span><span
lang=EN-US>)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>#pragma comment</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>lib</span><span lang=EN-US>, </span><span
lang=EN-US style='color:fuchsia'>&quot;Glu32.lib&quot;</span><span lang=EN-US>)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>#pragma comment</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>lib</span><span lang=EN-US>, </span><span
lang=EN-US style='color:fuchsia'>&quot;GlAux.Lib&quot;</span><span lang=EN-US>)&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// OpenGL auxiliary library</span></p>

<p class=MsoNormal><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>#include </span><span lang=EN-US style='color:fuchsia'>&lt;gl/gl.h&gt;</span><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp; </span><span lang=EN-US style='color:green'>//
standard OpenGL include</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>#include </span><span lang=EN-US style='color:fuchsia'>&lt;gl/glu.h&gt;</span><span
lang=EN-US>&nbsp;&nbsp;&nbsp; </span><span lang=EN-US style='color:green'>//
OpenGL utilities</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>#include </span><span
lang=EN-US style='color:fuchsia'>&lt;gl/GLAux.h&gt;&nbsp; </span><span
lang=EN-US style='color:green'>// OpenGL </span><span lang=EN-US
style='color:green'>Auxiliary</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>윈도우를 만들었으면 <span lang=EN-US>GetDC() </span>함수를 이용해<span
lang=EN-US> DC</span>를 생성 얻은 다음 <span lang=EN-US>PIXELFORMATDESCRIPTOR </span>구조체를
이용해서 우리가 필요로 하는 픽셀 형식을 다음과 같이 설정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>PIXELFORMATDESCRIPTOR</span><span lang=EN-US> pfd = {</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>반드시 초기화</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>pfd.nSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
</span><span lang=EN-US style='color:blue'>sizeof</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>PIXELFORMATDESCRIPTOR</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>pfd.nVersion&nbsp;&nbsp; =
</span><span lang=EN-US style='color:red'>1</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>pfd.dwFlags&nbsp;&nbsp;&nbsp; =
</span><span lang=EN-US style='color:#A000A0'>PFD_DRAW_TO_WINDOW</span><span
lang=EN-US> | </span><span lang=EN-US style='color:#A000A0'>PFD_SUPPORT_OPENGL</span><span
lang=EN-US> |</span><span lang=EN-US style='color:#A000A0'>PFD_DOUBLEBUFFER</span><span
lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>pfd.iPixelType =
</span><span lang=EN-US style='color:#A000A0'>PFD_TYPE_RGBA</span><span
lang=EN-US>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span lang=EN-US
style='color:green'>// </span><span style='color:green'>색상 모드<span lang=EN-US>:
RGBA</span></span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>pfd.cColorBits =
</span><span lang=EN-US style='color:red'>32</span><span lang=EN-US>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>색상<span
lang=EN-US> 32</span>비트</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>pfd.cDepthBits =
</span><span lang=EN-US style='color:red'>24</span><span lang=EN-US>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>깊이<span
lang=EN-US> 24</span>비트</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>pfd.cStencilBits=&nbsp;
</span><span lang=EN-US style='color:red'>8</span><span lang=EN-US>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>스텐실<span
lang=EN-US> 8</span>비트</span></p>

<p class=MsoNormal><span lang=EN-US>pfd.iLayerType = </span><span lang=EN-US
style='color:#A000A0'>PFD_MAIN_PLANE</span><span lang=EN-US>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Main Layer</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>이 구조체는 <span lang=EN-US>D3D</span>의 <a
name="_dx_d3dpresent_parameters_graphics"></a><span lang=EN-US>D3DPRESENT_PARAMETERS
</span>구조체와 비슷합니다<span lang=EN-US>. </span>여러분이 이 구조체에 대한 코드에서 변경해볼 만한 것은<span
lang=EN-US> ColorBit, DepthBit, StencilBit </span>정도 입니다<span lang=EN-US>. </span>앞의<span
lang=EN-US> PFD </span>플래그 값 <span lang=EN-US>DRAW_TO_WINDOW</span>은 픽셀 버퍼가 윈도우
혹은 장치의 서피스에 대한 렌더링을<span lang=EN-US>, SUPPORT_OPENGL</span>는 픽셀 버퍼가 <span
lang=EN-US>OpenGL</span>을 지원하는 것을<span lang=EN-US>, DOUBLEBUFFER </span>픽셀 버퍼의 이중
버퍼링을 의미합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>이렇게 구조체를 채우고<span lang=EN-US>DC</span>에서 지원이 되는지 다음과 같이 확인합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>UINT</span><span
lang=EN-US> PixelFormat = </span><span lang=EN-US style='color:#880000'>ChoosePixelFormat</span><span
lang=EN-US>(m_hDC, &amp;pfd);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>ChoosePixelFormat() </span>함수는 가장 근접한 형태의 포맷을
찾아주며 인덱스를 반환 합니다<span lang=EN-US>. </span>실패할 경우는 인덱스가<span lang=EN-US> 0</span>입니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal>다음으로 찾은 인덱스<span lang=EN-US>, PIXELFORMATDESCRIPTOR </span>구조체
값을 다음과 같이 <span lang=EN-US>DC</span>에 설정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>SetPixelFormat</span><span
lang=EN-US>(m_hDC, PixelFormat,&amp;pfd);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>설정이 성공하면<span lang=EN-US> DC</span>를 통해서<span lang=EN-US> RC</span>를
생성합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>m_hGlDC = </span><span lang=EN-US
style='color:#880000'>wglCreateContext</span><span lang=EN-US>(m_hDC);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>게임에서는 보통 하나의<span lang=EN-US> RC</span>만 사용하므로 곧바로<span
lang=EN-US> DC</span>에 현재의 렌더링 문맥으로 설정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>wglMakeCurrent</span><span lang=EN-US>(m_hDC, m_hGlDC);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>RC </span>생성이 끝났습니다<span lang=EN-US>. </span>렌더링이
제대로 되는지 색상 버퍼를 특정한 색으로<span lang=EN-US> glClearColor() </span>함수로 지정하고<span
lang=EN-US> glClear() </span>함수로 채웁니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glClearColor</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>0.0f</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0.6f</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0.8f</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1.0f</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// R, G, B, A</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glClear</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_COLOR_BUFFER_BIT</span><span
lang=EN-US> | </span><span lang=EN-US style='color:#A000A0'>GL_DEPTH_BUFFER_BIT</span><span
lang=EN-US> | </span><span lang=EN-US style='color:#A000A0'>GL_STENCIL_BUFFER_BIT</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>glClearColor() </span>함수는<span lang=EN-US>
[0, 1] </span>범위의 색상 값을<span lang=EN-US> Red, Green, Blue, Alpha </span>순으로<span
lang=EN-US> glClear() </span>함수가 호출되어 색상 버퍼를 특정한 색상으로 채울 때 그 색상을 지정하는 함수 입니다<span
lang=EN-US>. </span>디폴트 색상은<span lang=EN-US> (0,0,0,1)</span>입니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal>앞에서 <span lang=EN-US>PIXELFORMATDESCRIPTOR </span>구조체의 값에 깊이<span
lang=EN-US> 24, </span>스텐실<span lang=EN-US> 8 </span>비트를 사용했기 때문에 깊이와 색상 버퍼도 같이<span
lang=EN-US> Clear() </span>했습니다<span lang=EN-US>. </span>참고로<span lang=EN-US>
Clear</span>에 대한 디폴트 깊이<span lang=EN-US>(Depth) </span>값은<span lang=EN-US> 1.0 </span>이고<span
lang=EN-US>, </span>스텐실<span lang=EN-US>(Stencil)</span>은<span lang=EN-US> 0 </span>입니다<span
lang=EN-US>. </span>이들을 지정하려면<span lang=EN-US> glClearDepth(), glClearStencil()
</span>함수를 이용합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>렌더링에서 장치<span lang=EN-US>(DC)</span>에 대해서 전면 버퍼와 후면 버퍼 교체를 <span
lang=EN-US>SwapBuffers() </span>함수로 지시합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>SwapBuffers</span><span
lang=EN-US>(m_hDC);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>전면 버퍼 후면 버퍼 교체</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>프로그램을 종료하기 전에<span lang=EN-US> RC, DC, </span>윈도우 순으로 설정한 자원을
해제합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>wglMakeCurrent</span><span lang=EN-US>(m_hDC, </span><span
lang=EN-US style='color:#A000A0'>NULL</span><span lang=EN-US>);&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>장치에 대한 렌더링 문맥
설정 해제</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>wglDeleteContext</span><span lang=EN-US>(m_hGlDC);&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>렌더링 문맥 해제</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>ReleaseDC</span><span lang=EN-US>(m_hWnd, m_hDC);</span><span
lang=EN-US style='color:green'> &nbsp;&nbsp;&nbsp; // </span><span
style='color:green'>윈도우<span lang=EN-US> DC </span>해제</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl01_device.zip">gl01_device.zip</a></span>을
실행하면 다음과 같이 화면 전체에 지정한 색상이 출력되는 것을 볼 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=261 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image001.gif"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;OpenGL Rendering Context </span>생성<span
lang=EN-US>: </span><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl01_device.zip"><span
lang=PT-BR>gl01_device.zip</span></a></span><span lang=PT-BR>&gt;</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl01_device.zip">gl01_device.zip</a></span>을
실행하면 다음과 같이 화면 전체에 지정한 색상이 출력되는 것을 볼 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl01_device.zip">gl01_device.zip</a>
</span>예제는 게임 프로그램에 적합 형태는 아닙니다<span lang=EN-US>. D3D</span>에서와 마찬가지로<span
lang=EN-US> C++ </span>클래스로 구조화 하는 것이 좋습니다<span lang=EN-US>. </span><span
lang=PT-BR><a href="https://github.com/3dapi/et01_opengl/raw/master/gl01_device_c++.zip">gl01_device_c++.zip</a> </span>예제는<span
lang=PT-BR> CApplicationGL</span>에서 윈도우와<span lang=PT-BR> RC</span>에 대한 관리를 담당하고
게임 코드는<span lang=PT-BR> CApplicationGL </span>클래스를 상속 받은<span lang=PT-BR> CMain
</span>클래스에서 구현되도록 만든 예입니다<span lang=PT-BR>. CMain </span>클래스의 멤버 함수는 게임 데이터 생성<span
lang=PT-BR>/</span>소멸<span lang=PT-BR>/</span>갱신<span lang=PT-BR>/</span>렌더링에 대해서
처리할 수 있도록<span lang=PT-BR> Init()/Destroy()/FrameMove()/Render() </span>함수를 만들어
놓았습니다<span lang=PT-BR>.</span></p>

<p class=MsoNormal>앞으로 설명한 예제는 모두 <span lang=PT-BR><a href="https://github.com/3dapi/et01_opengl/raw/master/gl01_device_c++.zip">gl01_device_c++.zip</a></span>을
기반으로 작성되어 있습니다<span lang=PT-BR>.</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:14.0pt'>11.1.2 </span><span
style='font-size:14.0pt'>정점과 색상</span></p>

<p class=MsoNormal><span lang=EN-US>OpenGL</span>은 <span lang=EN-US>D3D</span>에
비해서 정점 출력이 상당히 유연하고 자유롭습니다<span lang=EN-US>. D3D</span>는 정점을 출력하기 위해서 정점 구조체<span
lang=EN-US>, </span>정점 버퍼<span lang=EN-US>, FVF </span>등을 설정해야 하지만<span
lang=EN-US> OpenGL</span>은 정점 버퍼뿐만 아니라 개별적인 데이터까지 조합해서 렌더링이 가능합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal>기본적인 렌더링 방법은 다음과 같습니다<span lang=PT-BR>.</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glBegin</span><span lang=EN-US>(</span><span lang=EN-US
style='color:red'>&quot;</span><span style='color:red'>프리미티브 타입<span
lang=EN-US>&quot;</span></span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex</span><span lang=EN-US>{</span><span
lang=EN-US style='color:#880000'>2</span><span lang=EN-US>|</span><span
lang=EN-US style='color:#880000'>3</span><span lang=EN-US>|</span><span
lang=EN-US style='color:#880000'>4</span><span lang=EN-US>}{</span><span
lang=EN-US style='color:#880000'>i</span><span lang=EN-US>|</span><span
lang=EN-US style='color:#880000'>s</span><span lang=EN-US>|</span><span
lang=EN-US style='color:#880000'>f</span><span lang=EN-US>|</span><span
lang=EN-US style='color:#880000'>d</span><span lang=EN-US>}[</span><span
lang=EN-US style='color:#880000'>v</span><span lang=EN-US>]({</span><span
lang=EN-US style='color:red'>&quot;</span><span style='color:red'>위치<span
lang=EN-US> x,&nbsp; y , z&quot;</span></span><span lang=EN-US>|</span><span
lang=EN-US style='color:red'>&quot;</span><span style='color:red'>위치 배열<span
lang=EN-US>&quot;</span></span><span lang=EN-US>});</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glEnd</span><span
lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=PT-BR>glBegin()/glEnd() </span>함수는 정점 렌더링의 시작과 끝을
알립니다<span lang=PT-BR>. </span>이것은<span lang=PT-BR> D3D</span>의<span lang=PT-BR>
DrawPrimitive()</span>함수를 호출 하는 것과 비슷합니다<span lang=PT-BR>. glBegin() </span>함수의
인수는 다음의 프리미티브 중에서 하나를 선택합니다<span lang=PT-BR>.</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>GL_POINTS: </span>점 리스트</p>

<p class=MsoNormal><span lang=EN-US>GL_LINES: 2</span>개의 정점 단위로 선을 구성</p>

<p class=MsoNormal><span lang=EN-US>GL_LINE_LOOP: </span>모든 정점이 순서대로 연결되어 폐곡선 형성</p>

<p class=MsoNormal><span lang=EN-US>GL_LINE_STRIP: </span>연결된 선 형성</p>

<p class=MsoNormal><span lang=EN-US>GL_TRIANGLES: 3</span>개의 정점 단위로 삼각형 구성</p>

<p class=MsoNormal><span lang=EN-US>GL_TRIANGLE_STRIP: </span>연결된 삼각형 형성<span
lang=EN-US>. </span>삼각형 감는 방법은 반 시계<span lang=EN-US>, </span>시계<span
lang=EN-US>, </span>반 시계<span lang=EN-US>,…</span>를 반복</p>

<p class=MsoNormal><span lang=PT-BR>GL_TRIANGLE_FAN: </span>부채꼴 모양으로 삼각형을 형성<span
lang=PT-BR>.</span></p>

<p class=MsoNormal><span lang=PT-BR>GL_QUADS: 4</span>개의 정점을 한 단위로 사각형 형성</p>

<p class=MsoNormal><span lang=PT-BR>GL_QUAD_STRIP: </span>연결된 사각형 형성</p>

<p class=MsoNormal><span lang=PT-BR>GL_POLYGON : </span>임의의 다각형 형성</p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal>이 중에서 가장 많이 사용되는 것은 <span lang=EN-US>GL_TRIANGLES, GL_LINES,
GL_POINTS </span>입니다<span lang=EN-US>. </span>만약 삼각형에 대해서 인덱스 버퍼를 사용하게 되면<span
lang=EN-US> D3D</span>와 마찬가지로 프리미티브 타입은 <span lang=EN-US>GL_TRIANGLES</span>이 됩니다<span
lang=EN-US>. </span>인덱스 버퍼를 사용하는 예는 정점 버퍼를 이용할 때 다시 설명하겠습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=576 height=169
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image002.gif"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;OpenGL Geometric Primitive Type&gt;</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>glVertex…() </span>함수는<span lang=EN-US> RC</span>에
전달하는 정점 데이터와 형식을 지정하는 함수 입니다<span lang=EN-US>. </span>처음에 나오는 숫자는 데이터의 차원입니다<span
lang=EN-US>. </span>다음의<span lang=EN-US> i, s, f, d</span>는 각각<span lang=EN-US>
int, short int, float, double </span>형을 말합니다<span lang=EN-US>. </span>마지막<span
lang=EN-US> v</span>는 인수에 전달할 값이 개별적인 값이 아닌 배열 형태일 때 사용합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>예를 들어 만약<span lang=EN-US> 2</span>차원<span lang=EN-US> int</span>형
데이터<span lang=EN-US> x, y</span>를 렌더링 하게 되면<span lang=EN-US> glVertex2i( x, y)</span>형식으로
작성합니다<span lang=EN-US>. </span>가장 많이 사용되는 함수는<span lang=EN-US> 3</span>차원에 대해서<span
lang=EN-US> glVertex3f(x, y, z)</span>또는<span lang=EN-US>
glVertex3v(&quot;float</span>형 배열<span lang=EN-US>&quot;)</span>입니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>다음은 화면에 삼각형 한 개를 그리는 예입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glBegin</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_TRIANGLES</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>( -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>(&nbsp; </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>(&nbsp; </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>,&nbsp; </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glEnd</span><span
lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=PT-BR><img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image003.gif"></span></p>

<p class=MsoNormal><span lang=PT-BR>&lt;</span>삼각형<span lang=PT-BR>: <a
href="https://github.com/3dapi/et01_opengl/raw/master/gl03_triangle.zip">gl03_triangle.zip</a>&gt;</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal>앞의 삼각형에 색상을 추가 하고 싶으면<span lang=PT-BR> glColor*() </span>함수 이용합니다<span
lang=PT-BR>. </span>다음의 예는 앞의 삼각형에 전체를 붉은 색으로 지정해서 렌더링 하는 예 입니다<span
lang=PT-BR>.</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glColor4f</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glBegin</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_TRIANGLES</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>( -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>(&nbsp; </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>(&nbsp; </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>,&nbsp; </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glEnd</span><span
lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=PT-BR><img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image004.gif"></span></p>

<p class=MsoNormal><span lang=PT-BR>&lt;</span>삼각형<span lang=PT-BR>-</span>색상<span
lang=PT-BR>: <a href="https://github.com/3dapi/et01_opengl/raw/master/gl03_triangle.zip">gl03_triangle.zip</a>&gt;</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=PT-BR>OpenGL</span>의 어떤 함수는 렌더링 머신의 상태 지정과 비슷해서 새로운
값이 오기 전까지 이전 값을 계속 유지하는 경향이 있습니다<span lang=PT-BR>. glColor*()</span>는 전체 정점 또는 개별
정점들에 대해서 색상을 지정합니다<span lang=PT-BR>. </span>만약 정점에 대해서 개별적인 색상을 지정하려면 다음과 같이 정점의
앞에<span lang=PT-BR> glColor*()</span>함수를 지정합니다<span lang=PT-BR>.</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glBegin</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_TRIANGLE_FAN</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glColor4f</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>( -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0F</span><span lang=EN-US>, -</span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0F</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glColor4f</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>(&nbsp; </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0F</span><span lang=EN-US>, -</span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0F</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glColor4f</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>(&nbsp; </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0F</span><span lang=EN-US>,&nbsp; </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0F</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glColor4f</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>( -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0F</span><span lang=EN-US>,&nbsp; </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0F</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glEnd</span><span
lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=PT-BR><img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image005.gif"></span></p>

<p class=MsoNormal><span lang=PT-BR>&lt;</span>사각형<span lang=PT-BR>: <a
href="https://github.com/3dapi/et01_opengl/raw/master/gl03_triangle.zip">gl03_triangle.zip</a>&gt;</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=PT-BR>glColor*() </span>함수 이외에 <span lang=PT-BR>glBegin()/glEnd()
</span>함수 안에서 가장 많이 사용하는 함수는 정점의 법선 벡터를 지정하는<span lang=PT-BR> glNormal*(), </span>텍스처
좌표를 지정하는<span lang=PT-BR> glTexCoord*(), glMultiTexCoord*ARB() </span>함수 들이고<span
lang=PT-BR>, </span>이 이외에 <span lang=PT-BR>glIndex*(), glEvalCoord*(),
glEvalPoint*(), glMaterial*(), glEdgeFlag*(), glCallList*() </span>함수 등도 종종 사용 됩니다<span
lang=PT-BR>.</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:14.0pt'>11.1.3 </span><span
style='font-size:14.0pt'>변환<span lang=EN-US>(Transform)</span></span></p>

<p class=MsoNormal>변환이라는 것은 그래픽 파이프라인 안에서 정점의 위치를 행렬과 곱해 새로운 위치를 만드는 과정입니다<span
lang=EN-US>. D3D</span>의 정점은 모델 좌표 <span lang=EN-US style='font-family:Wingdings'>&agrave;</span><span
lang=EN-US> </span>월드 좌표계 <span lang=EN-US style='font-family:Wingdings'>&agrave;</span><span
lang=EN-US> </span>뷰<span lang=EN-US>(View) </span>좌표계 <span lang=EN-US
style='font-family:Wingdings'>&agrave;</span><span lang=EN-US> </span>정규 좌표계 <span
lang=EN-US style='font-family:Wingdings'>&agrave;</span><span lang=EN-US> </span>장치 좌표계로
변환하고 이를 위해 우리는 각각의 좌표계에 대한 행렬을<span lang=EN-US> SetTransform() </span>함수를 이용해 지정해왔습니다<span
lang=EN-US>. OpenGL</span>이 변환에서<span lang=EN-US> D3D</span>와 차이는 월드 좌표계<span
lang=EN-US>, </span>뷰 좌표계 변환을 결합한 모델<span lang=EN-US>-</span>뷰<span lang=EN-US>(Model-View)
</span>좌표계 변환을 수행합니다<span lang=EN-US>. </span>그리고<span lang=EN-US> D3D</span>는 정규
변환을 거치면 정점의 위치<span lang=EN-US> x, y</span>는<span lang=EN-US> [-1, 1], z</span>는<span
lang=EN-US> [0, 1]</span>이지만<span lang=EN-US> OpenGL</span>은 정규 변환 후<span
lang=EN-US> x, y, z</span>는 전부 <span lang=EN-US>[-1, 1]</span>의 범위를 갖습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal>이전의 삼각형과 사각형 예제들은 이런 점을 이용해서 정점의 위치 값을<span lang=EN-US> -1, 0,
1 </span>에서 선택해서 만든 것입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=PT-BR>OpenGL</span>은<span lang=PT-BR> D3D</span>와
다르게 모든 것이 렌더링 머신의 상태를 함수로 결정할 수 있습니다<span lang=PT-BR>. </span>만약 모델<span
lang=PT-BR>_</span>뷰 행렬을 <span lang=PT-BR>RC</span>에 적용하려면 여러분은 다음과 같은 코드를 작성해야
합니다<span lang=PT-BR>.</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>float</span><span lang=EN-US>&nbsp;&nbsp; mtViw[</span><span
lang=EN-US style='color:red'>16</span><span lang=EN-US>]={</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>}; </span><span
lang=EN-US style='color:green'>// Model - View Matrix</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:green'>// Setup Model-View Matrix</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glMatrixMode</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_MODELVIEW</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glLoadIdentity</span><span lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glLoadMatrixf</span><span
lang=EN-US>(mtViw);</span></p>

<p class=MsoNormal><span lang=EN-US>glMatrixMode() </span>함수는 <span lang=EN-US>D3D</span>의<span
lang=EN-US> SetTransform() </span>함수와 같이 렌더링 머신의 변환 행렬을 지정하는 함수이며 모델<span
lang=EN-US>-</span>뷰 변환에 대한 인수는<span lang=EN-US> GL_MODELVIEW, </span>투영 변환에 대한
인수는<span lang=EN-US> GL_PROJECTION </span>입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>glLoadIdentity() </span>함수는 렌더링 머신의 현재 지정된 변환의
행렬을 단위 행렬<span lang=EN-US>(</span>항등 행렬<span lang=EN-US>)</span>로 초기화 하는 함수입니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>glLoadMatrix*() </span>함수는 머신의 행렬 스택에서 최상 위
행렬의 값을 변경하는 함수로 앞의 코드에서는 최상위 행렬이<span lang=EN-US> Model-View </span>변환 행렬입니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>만약 여러분들이 직접 행렬 값을 만들 때 주의할 것은<span lang=EN-US> OpenGL</span>의
모든 연산은 오른손 좌표 시스템을 기준으로 진행됩니다<span lang=EN-US>. </span>그런데<span lang=EN-US>
glLoadMatrix*()</span>함수가 요구하는 것은 행 우선이 아닌 열 우선 행렬 입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>이것은 연산의 속도를 빠르게 하기 위해서 연산 처리가<span lang=EN-US> &quot;</span>벡터<span
lang=EN-US>' = </span>행렬<span lang=EN-US> * </span>벡터<span lang=EN-US>&quot;</span>가
아닌<span lang=EN-US> D3D</span>처럼 내부에서 <span lang=EN-US>&quot;</span>벡터<span
lang=EN-US>'= </span>벡터<span lang=EN-US> * </span>행렬<span lang=EN-US>&quot; </span>을
수행하기 때문에 열 우선으로 값을 채워야 합니다<span lang=EN-US>. </span>이런 점이 있어<span lang=EN-US>
D3D SDK</span>의 수학 함수를 이용할 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>glLoadMatrix*() </span>함수를 사용하지 않고 모델<span
lang=EN-US>-</span>뷰 변환 행렬을 지정하려면<span lang=EN-US> OpenGL Utility </span>함수 <span
lang=EN-US>gluLookAt() </span>를 이용합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>다음은 카메라 위치가<span lang=EN-US> (0, 0, 10), </span>보고 있는 지점이<span
lang=EN-US> (0, 0, 0), Up </span>벡터가<span lang=EN-US> (0, 1, 0)</span>일 때 렌더링 머신의
모델<span lang=EN-US>-</span>뷰 행렬 값을 바꾸는 예입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glMatrixMode</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_MODELVIEW</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glLoadIdentity</span><span lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>gluLookAt</span><span
lang=EN-US>(</span><span lang=EN-US style='color:red'>0</span><span lang=EN-US>,</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>10</span><span lang=EN-US>,&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>,</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>,</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>,&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>,</span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>,</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>비슷하게 머신의 투영 행렬을 투시 투영<span lang=EN-US>(Perspective
Projection)</span>으로 바꿀 때는 <span lang=EN-US>gluPerspective()</span>함수를 다음과 같이 사용합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glMatrixMode</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_PROJECTION</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Projection </span><span style='color:green'>선택</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glLoadIdentity</span><span lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>gluPerspective</span><span
lang=EN-US>( </span><span lang=EN-US style='color:red'>45</span><span
lang=EN-US>, </span><span lang=EN-US style='color:blue'>float</span><span
lang=EN-US>(m_ScnW)/</span><span lang=EN-US style='color:blue'>float</span><span
lang=EN-US>(m_ScnH), </span><span lang=EN-US style='color:red'>1</span><span
lang=EN-US>.f, </span><span lang=EN-US style='color:red'>5000</span><span
lang=EN-US>.f);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>D3D</span>에서 사용하는 각도는<span lang=EN-US>
Radian </span>이지만<span lang=EN-US> OpenGL</span>에서 사용하는 모든 각도는<span lang=EN-US>
Degree </span>입니다<span lang=EN-US>. gluPerspective() </span>함수는 인수로<span
lang=EN-US> FOV(Field of View), Aspect Ratio, Near Value, Far Value </span>값을 받는데
이 때<span lang=EN-US> FOV </span>값은<span lang=EN-US> Degree </span>이어야 합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>만약 뷰포트 값을 바꾸고 싶을 때는 <span lang=EN-US>glViewport() </span>함수를
사용합니다<span lang=EN-US>. </span>뷰 포트는 지정하지 않으면<span lang=EN-US> DC</span>의 영역이 됩니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>D3D </span>는 디바이스의 함수를 호출해서 상태 값을 변경하기 때문에 함수의
순서가 바뀌어도 상관 없었습니다<span lang=EN-US>. </span>하지만<span lang=EN-US> OpenGL</span>은 함수의
호출 순서가 중요할 때가 있습니다<span lang=EN-US>. </span>예를 들어 다음과 같이<span lang=EN-US>
MODEL_VIEW</span>를 먼저 설정하고<span lang=EN-US>, PROJECTION</span>을 나중에 할 경우에<span
lang=EN-US> MODEL_VIEW</span>를 지정하지 않고 그냥<span lang=EN-US> glLoadMatrix*() </span>함수를
호출할 경우<span lang=EN-US> PROJECTION </span>행렬이 바뀌게 됩니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glMatrixMode</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_MOVELVIEW</span><span lang=EN-US>); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Model View </span><span style='color:green'>선택</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glMatrixMode</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_PROJECTION</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Projection </span><span style='color:green'>선택</span></p>

<p class=MsoNormal><span lang=EN-US>… </span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glLoadMatrixf</span><span
lang=EN-US>(…);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>원래의 의도는<span lang=EN-US> MODEL_VIEW </span>행렬을 변경하려고 한 것인데 <span
lang=EN-US>PROJECTION</span>행렬을 바꾸게 되었습니다<span lang=EN-US>. </span>이런 실수를 안 하려면<span
lang=EN-US> &quot;OpenGL</span>의 상태는 스택처럼 마지막에 지정된 것이 적용된다<span lang=EN-US>&quot;</span>라는
것을 명심하고 파이프라인에서 처리되는 순서를 거꾸로 적용해서 다음의 예와 같이 작성하는 것이 좋습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glViewport</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, m_ScnW, m_ScnH );&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>뷰포트 설정</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glMatrixMode</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_PROJECTION</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Projection </span><span style='color:green'>선택</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>gluPerspective</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>45</span><span lang=EN-US>, </span><span
lang=EN-US style='color:blue'>float</span><span lang=EN-US>(m_ScnW)/</span><span
lang=EN-US style='color:blue'>float</span><span lang=EN-US>(m_ScnH), </span><span
lang=EN-US style='color:red'>1.0f</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>5000.0f</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glMatrixMode</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_MODELVIEW</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Model View </span><span style='color:green'>선택</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>gluLookAt</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>,</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>10</span><span lang=EN-US>,&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>,</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>,</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>,&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>,</span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>,</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>물론<span lang=EN-US>, </span>항상 <span lang=EN-US>{glMatrixMode(),
glLoadMatrix*()} </span>로 코드를 작성하는 습관을 들이는 것이 가장 좋은 방법입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:14.0pt'>11.1.4 </span><span
style='font-size:14.0pt'>행렬 스택<span lang=EN-US>(Matrix Stack)</span></span></p>

<p class=MsoNormal>앞서<span lang=EN-US> OpenGL</span>은 월드 변환과 뷰 변환이 동시에 진행된다고 했습니다<span
lang=EN-US>. </span>월드 변환과 뷰 변환을 따로 지정할 수 없는 것은 여간 불편한 일이 아닐 수 없습니다<span
lang=EN-US>. </span>이 때는 모델<span lang=EN-US>-</span>뷰 변환 행렬은 카메라의 뷰 행렬로 지정하고 각 모델의
월드 변환은 행렬 스택을 이용해서 처리하는 것입니다<span lang=EN-US>. </span>행렬 스택의 종류는 모델<span
lang=EN-US>-</span>뷰 행렬 스택<span lang=EN-US>, </span>투영 행렬 스택<span lang=EN-US>, </span>텍스처
행렬 스택<span lang=EN-US> 3 </span>종류가 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>가장 많이 사용하는 모델<span lang=EN-US>-</span>뷰 행렬 스택의 예를 들어 봅시다<span
lang=EN-US>.</span></p>

<p class=MsoNormal>만약 여러분이 지역 좌표계로 설정되어 있는 모델을 월드 공간으로 이동하기 위해 다음과 같은 코드를 작성할 수
있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glMatrixMode</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_MODELVIEW</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glTranslatef</span><span
lang=EN-US>(-</span><span lang=EN-US style='color:red'>2</span><span
lang=EN-US>, </span><span lang=EN-US style='color:red'>1</span><span
lang=EN-US>, </span><span lang=EN-US style='color:red'>3</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>glTranslate*() </span>함수는 크기<span
lang=EN-US>, </span>회전<span lang=EN-US>, </span>이동 변환 중에서 이동 변환을 위해서 사용하는 함수이며 지정된
렌더링 머신의 행렬을 이동 변환 행렬을 곱한 결과로 교체하는 함수입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>앞의 코드는 결국 모델<span lang=EN-US>-</span>뷰 행렬을 다음과 같은 행렬 값으로 변경한
것과 다름이 없습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><sub><img border=0 width=263 height=96
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image006.gif"></sub></span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>이것은 하나의 모델과 하나의 카메라에서는 별 문제 없지만 여러 모델의 경우에 각각의 모델에 대해서 항상 <span
lang=EN-US>gluLookAt() </span>함수 또는<span lang=EN-US> glLoadMatrix*()</span>함수를 호출해서
렌더링 머신의 모델<span lang=EN-US>-</span>뷰 행렬을 지정해야 우리가 원하는 형태인 월드 변환 <span
lang=EN-US style='font-family:Wingdings'>&agrave;</span><span lang=EN-US> </span>뷰 변환을
만들 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>그런데 행렬 스택을 이용하면 매번 모델<span lang=EN-US>-</span>뷰 행렬을 지정 안 해도 됩니다<span
lang=EN-US>. </span>행렬 스택은 현재의 행렬을 스택의<span lang=EN-US> top</span>에 일시적으로 복사해 놓고
사용하는 것입니다<span lang=EN-US>. </span>행렬 스택의<span lang=EN-US> top</span>에 현재의 행렬을 복사하는
방법은<span lang=EN-US> glPushMatrix() </span>함수를 이용하고 해제는 <span lang=EN-US>glPopMatrix()</span>를
이용합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>예를 들어 다음과 같은 코드를 작성했다고 합시다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glMatrixMode</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_MODELVIEW</span><span
lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Model View </span><span style='color:green'>선택</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glPushMatrix</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glTranslatef</span><span lang=EN-US>(x, y, z);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glBegin</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TRIANGLES</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glEnd</span><span lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glPopMatrix</span><span
lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>glPushMatrix() </span>함수는 모델<span
lang=EN-US>-</span>뷰 행렬을 스택에 복사합니다<span lang=EN-US>. </span>다음으로<span
lang=EN-US> glTranslate*() </span>함수는 이동 변환 행렬을 만든 다음에 스택에 복사된 모델<span
lang=EN-US>-</span>뷰 행렬 곱합니다<span lang=EN-US>. </span>렌더링 머신은 이 곱한 행렬을 모델<span
lang=EN-US>-</span>뷰 행렬로 사용해서 정점을 변환합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>glPopMatrix() </span>함수를 이용해서 이전의 모델<span
lang=EN-US>-</span>뷰 행렬로 되돌아 옵니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>모델이 지역 좌표계에서 먼저 크기 변환하고<span lang=EN-US>, </span>회전 변환한 다음에 월드
좌표계의 위치로 이동하는 경우에 여러분은 다음과 같이 작성해야 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glPushMatrix</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glTranslate*</span><span lang=EN-US>(…);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glRotate*</span><span lang=EN-US>(…);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glScale*</span><span lang=EN-US>(…);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glBegin</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glEnd</span><span lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glPopMatrix</span><span
lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>D3DD</span>에서 모델의 월드 변환 행렬을 만들 때 크기 행렬<span
lang=EN-US> * </span>회전 행렬<span lang=EN-US> * </span>이동 행렬 순으로 곱했던 기억이 있습니다<span
lang=EN-US>. </span>또한 앞서<span lang=EN-US> OpenGL</span>의 렌더링 머신은 스택처럼 동작한다는 것을
생각한다면 정점을 그리는<span lang=EN-US> glBegin()</span>함수에서 가장 가까운 위치에 크기 변환 행렬이 있어야 하고<span
lang=EN-US>, </span>그 다음으로 회전<span lang=EN-US>, </span>이동 순서대로 코드를 작성해야 원하는 형태로
출력이 됩니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>glRotate*() </span>함수는 회전 변환 행렬을 만들고 지정된 행렬에
곱셈을 합니다<span lang=EN-US>. glScale*() </span>함수는 비슷하게 크기 변환 행렬을 만들고 지정된 행렬에 곱셈을 합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>앞의 코드는 다음과 같이 서술할 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i>모델<span lang=EN-US>-</span>뷰 행렬<span lang=EN-US>' = </span>이동
행렬<span lang=EN-US> * </span>모델<span lang=EN-US>-</span>뷰 행렬<span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (glTranslate)</span></i></p>

<p class=MsoNormal><i>모델<span lang=EN-US>-</span>뷰 행렬<span lang=EN-US>'' = </span>회전
행렬<span lang=EN-US> * </span>모델<span lang=EN-US>-</span>뷰 행렬<span lang=EN-US>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (glRotate)</span></i></p>

<p class=MsoNormal><i>모델<span lang=EN-US>-</span>뷰 행렬<span lang=EN-US>''' = </span>크기
변환 행렬<span lang=EN-US> * </span>모델<span lang=EN-US>-</span>뷰 행렬<span
lang=EN-US>''&nbsp;&nbsp;&nbsp; (glScale)</span></i></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>이것은 결국 우리가 원하는 다음과 같은 연산과 동일하게 됩니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i>새로운 모델<span lang=EN-US>-</span>뷰 행렬<span lang=EN-US> = </span>크기
변환 행렬<span lang=EN-US> * </span>회전 행렬<span lang=EN-US> * </span>이동 행렬<span
lang=EN-US> * </span>모델<span lang=EN-US>-</span>뷰 행렬</i></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>이렇게<span lang=EN-US> OpenGL</span>이 행렬의 연산을 열 중심으로 계산한다면 우리는<span
lang=EN-US> DXSDK</span>의 수학 함수를 사용해서<span lang=EN-US> OpenGL</span>를 좀 더 편리하게 사용할
수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>OpenGL</span>의 변환 행렬에 대해서 임의의 행렬을 곱한 결과를 새로운
변환 행렬로 지정하는 함수는 <span lang=EN-US>glMultMatrix*() </span>입니다<span lang=EN-US>. </span>이
함수를 사용해서 앞의 <span lang=EN-US>glTranslate*()</span>는<span lang=EN-US>
D3DXMatrixTranslate() </span>함수로 이동 행렬을 먼저 만들고 이동 행렬을 <span lang=EN-US>glMultMatrix*()
</span>함수로 곱합니다<span lang=EN-US>. glRotate*()</span>는 <span lang=EN-US>D3DXMatrixRotationAxis()
</span>함수로 회전 행렬을 만들고 이 회전 행렬을 <span lang=EN-US>glMultMatrix*() </span>함수를 호출에서
행렬을 곱하도록 합니다<span lang=EN-US>. glScale *()</span>는 <span lang=EN-US>D3DXMatrixScaling()
</span>함수로 크기 변환 행렬을 만들고 같은 방법으로 <span lang=EN-US>glMultMatrix*() </span>함수를 호출합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl04_transform1.zip">gl04_transform1.zip</a></span>의
<span lang=EN-US>CMain::Render() </span>함수에서 다음과 같이 직접<span lang=EN-US> OpenGL</span>의
렌더링 머신의 행렬을 설정하는 예와<span lang=EN-US> DXSDK </span>함수를 이용해서 행렬을 구하고 이를 적용하는 예가 있습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glPushMatrix</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glTranslatef</span><span lang=EN-US>(-</span><span
lang=EN-US style='color:red'>2</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glRotatef</span><span lang=EN-US>(fAngle, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glBegin</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TRIANGLES</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glEnd</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glPopMatrix</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glPushMatrix</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXMatrixTranslation</span><span lang=EN-US>(&amp;mtTrn,
</span><span lang=EN-US style='color:red'>2</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXMatrixRotationAxis</span><span lang=EN-US>(&amp;mtRot,
&amp;</span><span lang=EN-US style='color:blue'>D3DXVECTOR3</span><span
lang=EN-US>(</span><span lang=EN-US style='color:red'>0</span><span lang=EN-US>,
</span><span lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>), </span><span
lang=EN-US style='color:#A000A0'>D3DXToRadian</span><span lang=EN-US>(fAngle));</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glMultMatrixf</span><span lang=EN-US>((</span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>*)mtTrn);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glMultMatrixf</span><span lang=EN-US>((</span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>*)mtRot);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glBegin</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TRIANGLES</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glEnd</span><span lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glPopMatrix</span><span
lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=276 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image007.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;</span>변환<span lang=EN-US>: <a
href="https://github.com/3dapi/et01_opengl/raw/master/gl04_transform1.zip">gl04_transform1.zip</a>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>그런데 왜 우리는<span lang=EN-US> OpenGL</span>에서 지원되는 함수를 사용하지 않고<span
lang=EN-US> DXSDK </span>함수를 사용해서 행렬을 만들고 이를 적용하는 이와 같은 복잡한 과정을 하는 것일까요<span
lang=EN-US>?</span></p>

<p class=MsoNormal>단순히 렌더링만 하면 이와 같은 과정은 전혀 필요 없습니다<span lang=EN-US>. </span>그런데
게임 프로그램 안의 오브젝트 충돌을 생각해 봅시다<span lang=EN-US>. </span>결국 월드 행렬을 따로 가지고 있어야 합니다<span
lang=EN-US>. </span>그리고<span lang=EN-US> 3D </span>모델의 애니메이션을 생각해봅시다<span
lang=EN-US>. </span>애니메이션 데이터가 행렬로 되어 있으면<span lang=EN-US> glRotate*(),
glTranslate*() </span>함수에 맞게 회전과 이동 추출을 따로 구해서 작성하게 되어 일반적인 코드가 아닌 하나의 경우에만 사용하는
특별한 코드를 만들어야 합니다<span lang=EN-US>. </span>쉐이더<span lang=EN-US>, </span>카메라<span
lang=EN-US>, </span>기타 앞으로 닥칠 여러 상황에 대해서 생각한다면 렌더링과 데이터 갱신이 분리될 수 있도록 작업해야 하고 이것의
최초 모습은 앞서 보인 코드와 비슷할 것입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>DXSDK</span>의 수학 함수를 사용한 것은 현재 우리는 수학 함수를 따로
만들어 사용하고 있지 않기 때문입니다<span lang=EN-US>. </span>만약 여러분들이 작성한 수학 함수들이 있다면 그것으로 바꾸면
됩니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl04_transform2_dxmath.zip">gl04_transform2_dxmath.zip</a></span>은
<span lang=EN-US>OpenGL</span>의<span lang=EN-US> glRotate*(), glTranslate*() </span>함수
등을 사용하지 않고 수학 함수를 사용해서 월드 행렬을 구성한 다음 렌더링 예제 입니다<span lang=EN-US>. CMcScene::FrameMove()
</span>함수에서 다음과 같이 월드 행렬을 구성하고 <span lang=EN-US>CMcScene::DrawModel() </span>함수에서
행렬 스택 설정 안에서 모델<span lang=EN-US>-</span>뷰 행렬과 곱하고 있음을 볼 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>INT</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>CMcScene</span><span lang=EN-US>::</span><span lang=EN-US
style='color:#880000'>FrameMove</span><span lang=EN-US>()</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>D3DXMATRIX</span><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp; mtScl1;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>D3DXMATRIX</span><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp; mtRot1;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>D3DXMATRIX</span><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp; mtTrn1;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXMatrixScaling</span><span lang=EN-US>(&amp;mtScl1,
</span><span lang=EN-US style='color:red'>3</span><span lang=EN-US>.</span><span
lang=EN-US style='color:red'>0f</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>3</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>3</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXMatrixRotationAxis</span><span lang=EN-US>(&amp;mtRot1,
&amp;</span><span lang=EN-US style='color:blue'>D3DXVECTOR3</span><span
lang=EN-US>(</span><span lang=EN-US style='color:red'>0</span><span lang=EN-US>,
</span><span lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>), </span><span
lang=EN-US style='color:#A000A0'>D3DXToRadian</span><span lang=EN-US>(fAngle*</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>2f</span><span lang=EN-US>));</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXMatrixTranslation</span><span lang=EN-US>(&amp;mtTrn1,
-</span><span lang=EN-US style='color:red'>5</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_mtObj1
= mtScl1 * mtRot1 * mtTrn1;</span></p>

<p class=MsoNormal><span lang=EN-US>…</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>void</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>CMcScene</span><span lang=EN-US>::</span><span lang=EN-US
style='color:#880000'>DrawModel</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>D3DXMATRIX</span><span lang=EN-US>* mtWorld)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glPushMatrix</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glMultMatrixf</span><span lang=EN-US>((</span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>*)mtWorld);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glBegin</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TRIANGLE_FAN</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glEnd</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glPopMatrix</span><span lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=318 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image008.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;</span>행렬 스택과 모델의 월드 행렬<span
lang=EN-US>: </span><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl04_transform2_dxmath.zip">gl04_transform2_dxmath.zip</a></span><span
lang=EN-US>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:14.0pt'>11.1.5 </span><span
style='font-size:14.0pt'>조명<span lang=EN-US> (Lighting)</span></span></p>

<p class=MsoNormal><span lang=EN-US>OpenGL</span>과<span lang=EN-US> D3D</span>에서
사용되는 조명의 공식과 색상 처리는 같기 때문에 이론적인 부분은 넘어가겠습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>약간의 주의 사항은 방향 광원에 대해서 방향은 빛의 위치에서가 아니라 다음 그림처럼 정점의 위치에서 빛의 방향이
되어 원래 생각한 방향에<span lang=EN-US> &quot;-&quot; </span>를 붙여야 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=351 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image009.gif"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;OpenGL</span>에서 조명 계산에 관련한 벡터<span
lang=EN-US>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>조명을 효과를 만들기 위해서 조명의 위치<span lang=EN-US>, </span>색상<span
lang=EN-US>, </span>재질의 색상 등이 필요합니다<span lang=EN-US>. </span>조명의 위치는<span
lang=EN-US> x, y, z, w </span>값을 사용하는데<span lang=EN-US> w=1</span>이면 조명이 점 광원<span
lang=EN-US>(Point Light)</span>임을<span lang=EN-US>, w=0</span>이면 조명이 방향 광원<span
lang=EN-US> (Directional Light)</span>를 의미합니다<span lang=EN-US>. Spot Light</span>는
따로 설정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>또한<span lang=EN-US> OpenGL</span>은 하나의 렌더링 오브젝트에 조명을<span
lang=EN-US> 8</span>개까지<span lang=EN-US>(LIGHT0 ~ LIGHT7) </span>설정할 수 있습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>방향 광원을 설정하려면 다음과 같이 조명의 방향과 색상을 지정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>D3DXVECTOR4</span><span lang=EN-US>&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>LgtPos0</span><span lang=EN-US>(-</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>,-</span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, -</span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>조명 방향</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>D3DXCOLOR</span><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span lang=EN-US
style='color:#880000'>LgtCol0</span><span lang=EN-US>( </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>,&nbsp; </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>조명 색상</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>이 조명을<span lang=EN-US> 0</span>번 인덱스<span lang=EN-US>
Lighting</span>으로 설정하기 위해서 우리는<span lang=EN-US> glLightfv() </span>함수를 다음과 같이 사용합니다<span
lang=EN-US>. </span>램버트 확산에 대해서<span lang=EN-US> OpenGL</span>의 조명은<span
lang=EN-US> Diffuse Lighting</span>으로 구현되어 있습니다<span lang=EN-US>. Diffuse
Lighting </span>에 대해서 다음과 같이 대해서 설정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glLightfv</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_LIGHT0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_DIFFUSE</span><span lang=EN-US>,&nbsp; (</span><span
lang=EN-US style='color:blue'>GLfloat</span><span lang=EN-US>*)LgtCol0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// 0 </span><span style='color:green'>번 조명 <span
lang=EN-US>Diffuse </span>색상 설정</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glLightfv</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_LIGHT0</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_POSITION</span><span
lang=EN-US>, (</span><span lang=EN-US style='color:blue'>GLfloat</span><span
lang=EN-US>*)LgtPos0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// 0 </span><span style='color:green'>번 조명<span
lang=EN-US>(</span>방향<span lang=EN-US>) </span>설정</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>glLightfv() </span>함수의 두 번째 인수는 조명을 구성하는<span
lang=EN-US> Ambient, Diffuse, Specular </span>등의 색상과 조명의 위치<span lang=EN-US>, </span>감쇠도<span
lang=EN-US>, CUTOFF </span>등을 지정하는 인수입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>조명의 설정이 끝나면 반사에 대한 오브젝트의 재질을 설정합니다<span lang=EN-US>. </span>재질은
조명의 색상과 연산이 필요하기 때문에 색상 값을 가지고 다음과 같이 설정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>D3DXCOLOR</span><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span lang=EN-US
style='color:#880000'>MtlCol</span><span lang=EN-US>( </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>재질 색상</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glColorMaterial</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_FRONT</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_AMBIENT_AND_DIFFUSE</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glMaterialfv</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_FRONT</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_DIFFUSE</span><span
lang=EN-US>, (</span><span lang=EN-US style='color:blue'>GLfloat</span><span
lang=EN-US>*)MtlCol);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>정점을 그리기 전에 전체 조명과 각각 설정한 조명<span lang=EN-US>, </span>그리고 재질을
활성화 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glEnable</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_LIGHTING</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glEnable</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_LIGHT0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glEnable</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_COLOR_MATERIAL</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>모델의 렌더링 하기 전에 활성화한 <span lang=EN-US>GL_COLOR_MATERIAL </span>값은
색상 추적<span lang=EN-US>(Color Tracking) </span>으로 오브젝트가 색상을 가질 때<span
lang=EN-US>(</span>즉<span lang=EN-US>, glColor*() </span>함수가 호출될 때<span
lang=EN-US>) </span>자동으로 지정한 색이 재질 속성들로 적용되도록 합니다<span lang=EN-US>. </span>이 값은
디폴트로 비활성화 되어 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>마지막으로 컬링을 통해서 뒷면을 그리지 못하게 하고<span lang=EN-US>, </span>깊이 테스트를
활성화 합니다<span lang=EN-US>. </span>다각형을 반시계 방향<span lang=EN-US>(CCW: Counter
Clock Wise)</span>로 그리도록 한 다음 모델을 그립니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glEnable</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_CULL_FACE</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glEnable</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_DEPTH_TEST</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glFrontFace</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_CCW</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>…</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>DrawModel</span><span
lang=EN-US>(&amp;m_mtObj);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image010.jpg">&nbsp;<img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image011.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;Lighting: Flat-shading,
Gouraud-shading&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>Highlight</span>를 만드는 <span lang=EN-US>Specular
Lighting</span>은 조명에서 가장 매력적인 효과입니다<span lang=EN-US>. OpenGL</span>의<span
lang=EN-US> Specular Lighting</span>은 퐁<span lang=EN-US>(Phone) </span>반사를 이용합니다<span
lang=EN-US>. </span>이 효과를 구현하는 방법은 앞서 보인<span lang=EN-US> Diffuse Lighting</span>과
유사합니다<span lang=EN-US>. </span>만약 두 개의<span lang=EN-US> Specular </span>조명을 사용할
때는 다음과 같이 조명과 재질에 대한 위치<span lang=EN-US>, </span>색상 등을 설정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>D3DXVECTOR4</span><span lang=EN-US>&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>LgtPos0</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>5f</span><span lang=EN-US>,&nbsp; </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>5f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>조명 방향<span
lang=EN-US> 0</span></span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>D3DXCOLOR</span><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>LgtSpc0</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>4f</span><span lang=EN-US>,&nbsp; </span><span lang=EN-US
style='color:red'>3</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>조명 색상<span
lang=EN-US> 0</span></span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>D3DXVECTOR4</span><span lang=EN-US>&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>LgtPos1</span><span lang=EN-US>(-</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>,-</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>5f</span><span lang=EN-US>, -</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>5f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>조명 방향<span
lang=EN-US> 1</span></span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>D3DXCOLOR</span><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>LgtSpc1</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>9f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>4f</span><span lang=EN-US>,&nbsp; </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>4f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>조명 색상<span
lang=EN-US> 1</span></span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>D3DXCOLOR</span><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>MtlColS</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>6f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>6f</span><span lang=EN-US>,&nbsp; </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>6f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>재질 색상</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>GL_SPECULAR</span>는
현재 설정하는 조명이<span lang=EN-US> Specular Lighting </span>임을 나타내며<span lang=EN-US>
High Light</span>를 만들어 냅니다<span lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glLightfv</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_LIGHT0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_POSITION</span><span lang=EN-US>, (</span><span
lang=EN-US style='color:blue'>GLfloat</span><span lang=EN-US>*)LgtPos0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// 0 </span><span style='color:green'>번 조명 위치<span
lang=EN-US>(</span>방향<span lang=EN-US>) </span>설정</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glLightfv</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_LIGHT0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_SPECULAR</span><span lang=EN-US>, (</span><span
lang=EN-US style='color:blue'>GLfloat</span><span lang=EN-US>*)LgtSpc0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// 0 </span><span style='color:green'>번 조명<span
lang=EN-US> Specular </span>색상 설정</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glLightfv</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_LIGHT1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_POSITION</span><span lang=EN-US>, (</span><span
lang=EN-US style='color:blue'>GLfloat</span><span lang=EN-US>*)LgtPos1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// 1 </span><span style='color:green'>번 조명 위치<span
lang=EN-US>(</span>방향<span lang=EN-US>) </span>설정</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glLightfv</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_LIGHT1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_SPECULAR</span><span lang=EN-US>, (</span><span
lang=EN-US style='color:blue'>GLfloat</span><span lang=EN-US>*)LgtSpc1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// 1 </span><span style='color:green'>번 조명<span
lang=EN-US> Specular </span>색상 설정</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>Diffuse
Lighting</span>과 비슷하게 재질에서도 조명과 곱셈 연산을 하는<span lang=EN-US> Specular Lighting</span>의
색상을 적용합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glMaterialfv</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_FRONT</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_SPECULAR</span><span lang=EN-US>,(</span><span
lang=EN-US style='color:blue'>GLfloat</span><span lang=EN-US>*)MtlColS);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>Specular
Lighting</span>의 반사 세기<span lang=EN-US>(</span>퐁 반사 효과<span lang=EN-US>)</span>는
다음과 같이 결정 된다고 했습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US><sub><img
border=0 width=89 height=29 src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image012.gif"></sub>, <sub><img
border=0 width=15 height=21 src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image013.gif"></sub>: </span>시선
벡터<span lang=EN-US>, <sub><img border=0 width=17 height=21
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image014.gif"></sub>: </span>반사 벡터<span lang=EN-US>, </span></p>

<p class=MsoNormal style='word-break:keep-all'>이<span lang=EN-US> Power </span>값은<span
lang=EN-US> OpenGL</span>에서는<span lang=EN-US> Shininess</span>라 합니다<span
lang=EN-US>. </span>이 값은 재질에서 다음과 같이 설정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glMaterialf</span><span lang=EN-US> (</span><span
lang=EN-US style='color:#A000A0'>GL_FRONT</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_SHININESS</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>90</span><span lang=EN-US>.</span><span
lang=EN-US style='color:red'>0F</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>Specular </span>효과에 대해서 조명과 재질의 설정이 끝났습니다<span
lang=EN-US>. <a href="https://github.com/3dapi/et01_opengl/raw/master/gl05_lighting_specular.zip">gl05_lighting_specular.zip</a></span>을
실행하면 다음과 같이<span lang=EN-US> High Light 2</span>개가 만들어진 화면을 볼 수 있습니다<span
lang=EN-US>. </span>이 예제는<span lang=EN-US> Specular </span>이외에<span lang=EN-US>
Diffuse Light</span>도 같이 적용했습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image015.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;Specular-Diffuse Lighting: <a
href="https://github.com/3dapi/et01_opengl/raw/master/gl05_lighting_specular.zip">gl05_lighting_specular.zip</a>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:14.0pt'>11.1.6 </span><span
style='font-size:14.0pt'>텍스처</span></p>

<p class=MsoNormal>변환<span lang=EN-US>, </span>조명<span lang=EN-US>, </span>텍스처는<span
lang=EN-US> 3D </span>프로그램에서 가장 기초적인 부분입니다<span lang=EN-US>. OpenGL</span>은 오른손
좌표계를 사용하기 때문에 다음과 같은 텍스처 좌표계<span lang=EN-US>(ST-</span>좌표계<span lang=EN-US>)</span>를
사용합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='border-collapse:collapse'>
 <tr>
  <td width=283 valign=top style='width:212.4pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US><img border=0 width=240 height=188
  src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image016.jpg"></span></p>
  <p class=MsoNormal><span lang=EN-US>&lt;OpenGL, Max</span>의<span lang=EN-US>
  ST</span>좌표계<span lang=EN-US>&gt;</span></p>
  </td>
  <td width=276 valign=top style='width:207.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US><img border=0 width=233 height=181
  src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image017.jpg"></span></p>
  <p class=MsoNormal><span lang=EN-US>&lt;D3D</span>의<span lang=EN-US> UV </span>좌표계<span
  lang=EN-US>&gt;</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>OpenGL</span>도<span lang=EN-US> D3D </span>와
마찬가지로 텍스처 처리에 대한<span lang=EN-US> Addressing, Filtering, Multi-texturing</span>이
있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>만약 하나의 단계 대한 텍스처 매핑에서<span lang=EN-US> OpenGL</span>은 기본 함수를
이용해서 처리할 수 있습니다<span lang=EN-US>. </span>그런데 여러 단계의 텍스처를 처리하는 다중 텍스처 처리<span
lang=EN-US>(Multi-Texturing)</span>는<span lang=EN-US> OpenGL ARB(Architectural
Review Board)</span>에서 정의한 함수를 질의<span lang=EN-US>(Query)</span>를 통해서 얻어와 사용합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal>먼저 하나의 단계에서 처리되는 텍스처 매핑을 살펴 봅시다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>OpenGL</span>은 텍스처를<span lang=EN-US> &quot;</span>텍스처
이름<span lang=EN-US>&quot;</span>으로 구분해서 사용하는데 먼저<span lang=EN-US> &quot;</span>텍스처
이름<span lang=EN-US>&quot;</span>을 만들고 이 이름에 픽셀을 결합해야 합니다<span lang=EN-US>. &quot;</span>텍스처
이름<span lang=EN-US>&quot;</span>은 <span lang=EN-US>unsigned int </span>형으로 정의되어
있고 <span lang=EN-US>glGenTextures() </span>함수를 사용해서<span lang=EN-US> &quot;</span>텍스처
이름<span lang=EN-US>&quot;</span>을 생성합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>GLuint</span><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nTex;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>텍스처 이름</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glGenTextures</span><span lang=EN-US> (</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>,&amp;m_nTex);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'>해제는<span lang=EN-US>
glDeleteTextures() </span>함수를 이용합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glDeleteTextures</span><span lang=EN-US> (</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, &amp;m_nTex);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'>이<span lang=EN-US> &quot;</span>텍스처
이름에<span lang=EN-US>&quot; </span>여러분은 픽셀 데이터를 연결<span lang=EN-US>(Binding)</span>하기
위해서 <span lang=EN-US>glBindTexture() </span>함수를 먼저 호출하고 다음과 같이<span lang=EN-US>
glTexImage2D() </span>함수를 호출 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glBindTexture</span><span lang=EN-US> (</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>,
m_nTex);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glTexImage2D</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>4</span><span lang=EN-US>, nImgW, nImgH, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_RGBA</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_UNSIGNED_BYTE</span><span lang=EN-US>,
pPxl);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>glBindTexture()
</span>함수는 두 번째 인수의 값을<span lang=EN-US> 0</span>으로 지정할 때까지 이후 프로세스에 계속 유효하며 이 때
지정된 상태들은 <span lang=EN-US>&quot;</span>텍스처 이름<span lang=EN-US>&quot;</span>과 렌더링
처리에 영향을 줍니다<span lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=PT-BR>glTexImag2D() </span>함수는<span
lang=PT-BR> glBindTexture() </span>함수에서 지정한<span lang=PT-BR> &quot;</span>텍스처 이름<span
lang=PT-BR>&quot;</span>에 픽셀 데이터를 로드 하는 함수 입니다<span lang=PT-BR>. </span>이 함수의 세
번째 인수는 색상을 구성하는 컴포넌트로<span lang=PT-BR> 1,2,3,4 </span>중에 선택하거나 색상이 <span
lang=PT-BR>24</span>비트<span lang=PT-BR> RGB</span>이면<span lang=PT-BR> 3 </span>또는<span
lang=PT-BR> GL_RGB</span>를<span lang=PT-BR>, </span>알파가 있는<span lang=PT-BR> 32</span>비트
색상의 경우 <span lang=PT-BR>4 </span>또는 <span lang=PT-BR>GL_RGBA</span>를 사용합니다<span
lang=PT-BR>. </span>게임 프로그램에서는<span lang=PT-BR> GL_RGBA </span>혹은<span
lang=PT-BR> 4</span>를 가장 많이 사용합니다<span lang=PT-BR>.</span></p>

<p class=MsoNormal style='word-break:keep-all'>네 번째<span lang=PT-BR>, </span>다섯
번째 인수는 각각 이미지의 너비와 높이인데 문서에는<span lang=PT-BR> 2</span>의 승수<span lang=PT-BR> 2<sup>M</sup>
</span>을 사용하라고 하지만 그냥 이미지 너비와 폭을 넣어도 상관 없습니다<span lang=PT-BR>. 7 </span>번째 인수는 픽셀
데이터 포맷으로 세 번째 인수로 지정한 형식에 맞추어야 하며<span lang=EN-US> GL_RGB, GL_RGBA, GL_LUMINANCE</span>를
가장 많이 사용합니다<span lang=EN-US>. 8 </span>번째 인수는 픽셀을 구성하고 있는 성분의 형식입니다<span
lang=EN-US>. </span>게임 프로그램에서는<span lang=EN-US> 32</span>비트<span lang=EN-US>
RGBA </span>를 가장 많이 사용하기 때문에 <span lang=EN-US>GL_UNSIGNED_BYTE </span>값을 주로 사용합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>만약 밉맵이 필요하다면<span lang=EN-US> glBindTexture() </span>함수 호출 후에
<span lang=EN-US>gluBuild2DMipmaps ()</span>함수를 사용해서 자동으로 밉맵을 구성합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>gluBuild2DMipmaps</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>4</span><span lang=EN-US>, nImgW, nImgH, </span><span
lang=EN-US style='color:#A000A0'>GL_RGBA</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_UNSIGNED_BYTE</span><span lang=EN-US>,
pPxl);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'>텍스처에 픽셀을 로드하고 밉맵까지 만들었으면 바인딩을 해제합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glBindTexture</span><span
lang=EN-US> (</span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span
lang=EN-US>, </span><span lang=EN-US style='color:red'>0</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>픽셀이 텍스처에 로드 되었으므로 사용한 픽셀도 해제 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>delete</span><span
lang=EN-US> pPxl;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&quot;</span>텍스처 이름<span lang=EN-US>&quot;</span>을
해제하면 내부에서 로드 한 픽셀은 자동으로 소멸됩니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>렌더링은<span lang=EN-US> glEnable() </span>함수호출로 시작합니다<span
lang=EN-US>. OpenGL</span>은<span lang=EN-US> 1</span>차원에서<span lang=EN-US> 3</span>차원
텍스처까지 사용할 수 있지만<span lang=EN-US> 2</span>차원 텍스처를 주로 사용하고 있기 때문에 대부분 이 함수의 인수 값은
<span lang=EN-US>GL_TEXTURE_2D</span>입니다<span lang=EN-US>. </span>다음으로 현재의 렌더링에
텍스처 이름을 사용하기 위해서<span lang=EN-US> glBindTexture() </span>함수를 사용합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glEnable</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glBindTexture</span><span
lang=EN-US> (</span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span
lang=EN-US>, m_nTex);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>텍스처 샘플링에 대한 필터링<span lang=EN-US>(Filtering)</span>과 어드레싱<span
lang=EN-US>(Addressing)</span>은 <span lang=EN-US>glTexParameteri() </span>함수를 사용합니다<span
lang=EN-US>. </span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glTexParameteri</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_MAG_FILTER</span><span lang=EN-US>,
</span><span lang=EN-US style='color:#A000A0'>GL_NEAREST</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glTexParameteri</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_MIN_FILTER</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_NEAREST</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glTexParameteri</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_WRAP_S</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_REPEAT</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glTexParameteri</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_WRAP_T</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_REPEAT</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>모델을 장면에 그리고 나서 현재의<span lang=EN-US> &quot;</span>텍스처 이름<span
lang=EN-US>&quot; 0</span>으로 설정합니다<span lang=EN-US>. </span>이렇게 하면 다른 처리 과정에서 현재
사용한 텍스처의 영향을 안 받습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>DrawModel();</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glBindTexture</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span
lang=EN-US>, </span><span lang=EN-US style='color:red'>0</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>마지막으로 렌더링 머신의 텍스처 사용을 해제 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glDisable</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl06_tex1_single.zip">gl06_tex1_single.zip</a></span>은
텍스 매핑에 대한 예제입니다<span lang=EN-US>. </span>키보드의<span lang=EN-US> 'N'</span>키와<span
lang=EN-US> 'R'</span>키를 눌러 보면 텍스처 필터링과 어드레싱 적용에 대해서 출력 변화를 볼 수 있습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image018.jpg">&nbsp;<img border=0 width=273 height=202
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image019.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;</span>텍스처 매핑<span lang=EN-US>:
Addressing-Repeat, Clamp&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl06_tex1_single.zip">gl06_tex1_single.zip</a></span>은<span
lang=EN-US> BMP, TGA, PNG </span>파일에서 픽셀을 읽어오는 클래스 <span lang=EN-US>CGLImage </span>가
있으며 이 클래스는 인터페이스 <span lang=EN-US>IGLImage </span>클래스를 상속 받습니다<span lang=EN-US>.
</span>이 강의의 목적은 텍스처 매핑이기 때문에 이미지에서 픽셀을 읽어오는 내용을 생략했습니다<span lang=EN-US>. </span>참고로<span
lang=EN-US> BMP, TGA </span>파일은 픽셀 순서대로 읽으면 되나<span lang=EN-US> PNG</span>의 경우 이미지의
위<span lang=EN-US>, </span>아래를 바꾸어 주어야 합니다<span lang=EN-US>. </span>그런데 오히려<span
lang=EN-US> BMP, TGA</span>를 반대로 적용하고<span lang=EN-US> PNG</span>를 그대로 적용하는 시스템도
있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>OpenGL</span>에서 다중 텍스처<span lang=EN-US>(Multi-Texturing)
</span>처리를 간단히 정리하면 다음과 같습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>1. </span>다중 텍스처 지원을 확인한다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>2. </span>확장 함수 포인터를 얻는다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>3. </span>텍스처를 생성한다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>4. </span>다중 텍스처 단계에 대한 필터링<span
lang=EN-US>, </span>어드레싱 색상 연산<span lang=EN-US>(Operation)</span>을 지정한다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>5. </span>텍스처 좌표를 지정하고 모델을 그린다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>하드웨어에서 다중 텍스처 지원이 되는지 <span lang=EN-US>glGetString()</span>함수를
통해서 확장된 목록을 구합니다<span lang=EN-US>. </span>그리고 이 목록에서<span lang=EN-US>
&quot;GL_ARB_multitexture&quot; </span>이 있는지 확인합니다<span lang=EN-US>. </span>목록에
대한 확장 내용은 공백<span lang=EN-US>(' ')</span>으로 구분되어 있습니다<span lang=EN-US>. </span>여러분은
이 목록을 구분하기 위해서 다음과 같은 함수를 만들어야 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>INT</span><span lang=EN-US> </span><span lang=EN-US
style='color:#880000'>EnumExtension</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>char</span><span lang=EN-US>* sCheck, </span><span
lang=EN-US style='color:blue'>char</span><span lang=EN-US>* sGetStrings)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>char</span><span lang=EN-US>*&nbsp;&nbsp; sSrc=
sGetStrings;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>char</span><span lang=EN-US>&nbsp;&nbsp;&nbsp; seps[]&nbsp;&nbsp;
= </span><span lang=EN-US style='color:fuchsia'>&quot; &quot;</span><span
lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>char</span><span lang=EN-US>*&nbsp;&nbsp; token;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token
= </span><span lang=EN-US style='color:#880000'>strtok</span><span lang=EN-US>(
sSrc, seps );</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>while</span><span lang=EN-US>( token != </span><span
lang=EN-US style='color:#A000A0'>NULL</span><span lang=EN-US> )</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>if</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US> == </span><span
lang=EN-US style='color:#880000'>_stricmp</span><span lang=EN-US>(sCheck, token))</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>return</span><span lang=EN-US> </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token
= </span><span lang=EN-US style='color:#880000'>strtok</span><span lang=EN-US>(
</span><span lang=EN-US style='color:#A000A0'>NULL</span><span lang=EN-US>,
seps );</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>return</span><span lang=EN-US> -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>;</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US>…</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>char</span><span
lang=EN-US>* sExtension = (</span><span lang=EN-US style='color:blue'>char</span><span
lang=EN-US>*)</span><span lang=EN-US style='color:#880000'>glGetString</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_EXTENSIONS</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>hr = </span><span lang=EN-US
style='color:#880000'>EnumExtension</span><span lang=EN-US>(</span><span
lang=EN-US style='color:fuchsia'>&quot;GL_ARB_multitexture&quot;</span><span
lang=EN-US>, sExtension);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>strtok() </span>함수는 구분자<span lang=EN-US>(Delimit)</span>와
문자열을 입력하면 해당 문자열을 구분자에 지정된 기호들로 분리해 주는 편리한 함수 입니다<span lang=EN-US>. </span>게임 프로그램에서
자료를 해석할 때 자주 사용되는 함수입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>확장 함수 포인터를 얻어오기 위한 함수는 위글 함수 <span lang=EN-US>wglGetProcAddress()</span>를
이용합니다<span lang=EN-US>. </span>이 함수는<span lang=EN-US> DLL</span>에서 함수를 얻고자 할 때 사용하는
함수<span lang=EN-US> GetProcAddress()</span>와 많이 닮았습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>다중 텍스처에 사용되는 함수는 <span lang=EN-US>glMultiTexCoord2fARB(), glActiveTextureARB(),
glClient-ActiveTextureARB() </span>입니다<span lang=EN-US>. </span>이 함수를 사용하기 위해서 먼저
다음과 같이 함수 포인터를 작성합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>PFNGLMULTITEXCOORD2FARBPROC</span><span lang=EN-US>&nbsp;&nbsp; glMultiTexCoord2fARB
= </span><span lang=EN-US style='color:#A000A0'>NULL</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>PFNGLACTIVETEXTUREARBPROC</span><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp; glActiveTextureARB
= </span><span lang=EN-US style='color:#A000A0'>NULL</span><span lang=EN-US>;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>PFNGLCLIENTACTIVETEXTUREARBPROC</span><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glClientActiveTextureARB = </span><span
lang=EN-US style='color:#A000A0'>NULL</span><span lang=EN-US>;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>PFNGLMULTITEXCOORD2FARBPROC, PFNGLACTIVETEXTUREARBPROC,
PFNGLCLIENTACTIVETEXTUREARBPROC </span>에 대한 형식은<span lang=EN-US> glext.h </span>파일에
선언되어 있습니다<span lang=EN-US>. </span>만약 여러분의 컴파일러에<span lang=EN-US> glext.h </span>파일이
없으면 <span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/http://www.opengl.org/registry/api/glext.h">http://www.opengl.org/registry/api/glext.h</a></span>에서
최신<span lang=EN-US> glext.h </span>파일을 구할 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>CMcScene::Init() </span>함수에서 함수 포인터를 다음과 같이
구하고 있음을 볼 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>glActiveTextureARB
= </span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (</span><span
lang=EN-US style='color:blue'>PFNGLACTIVETEXTUREARBPROC</span><span lang=EN-US>)
</span><span lang=EN-US style='color:#880000'>wglGetProcAddress</span><span
lang=EN-US>(</span><span lang=EN-US style='color:fuchsia'>&quot;glActiveTextureARB&quot;</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>glMultiTexCoord2fARB
=</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (</span><span
lang=EN-US style='color:blue'>PFNGLMULTITEXCOORD2FARBPROC</span><span
lang=EN-US>) </span><span lang=EN-US style='color:#880000'>wglGetProcAddress</span><span
lang=EN-US>(</span><span lang=EN-US style='color:fuchsia'>&quot;glMultiTexCoord2fARB&quot;</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>glClientActiveTextureARB =</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (</span><span
lang=EN-US style='color:blue'>PFNGLCLIENTACTIVETEXTUREARBPROC</span><span
lang=EN-US>)</span><span lang=EN-US style='color:#880000'>wglGetProcAddress</span><span
lang=EN-US>(</span><span lang=EN-US style='color:fuchsia'>&quot;glClientActiveTextureARB&quot;</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>텍스처 이름을 생성하고<span lang=EN-US>, </span>픽셀 바인딩은 넘어가겠습니다<span
lang=EN-US>. OpenGL</span>은 함수 중심으로 구성되어 있고 각 함수들이 영향을 주는 범위가 있어서 호출 순서가 중요합니다<span
lang=EN-US>. </span>렌더링에서 멀티 텍스처를 적용하는 방법에도 함수의 호출 순서를 꼭 지키는 것이 중요하며 함수 호출 순서는 <span
lang=EN-US>glActiveTexture-ARB() </span><span lang=EN-US style='font-family:
Wingdings'>&agrave;</span><span lang=EN-US> glEnable() </span><span lang=EN-US
style='font-family:Wingdings'>&agrave;</span><span lang=EN-US> glBindTexture() </span><span
lang=EN-US style='font-family:Wingdings'>&agrave;</span><span lang=EN-US>
glTexParameteri() </span><span lang=EN-US style='font-family:Wingdings'>&agrave;</span><span
lang=EN-US> glTexEnvi() </span><span lang=EN-US style='font-family:Wingdings'>&agrave;</span><span
lang=EN-US> … </span>으로 진행 됩니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>glActiveTextureARB() </span>함수는 현재 적용되는 다중 텍스처
단위<span lang=EN-US>(Stage)</span>를 지정하는 함수 입니다<span lang=EN-US>. </span>이 함수는<span
lang=EN-US> D3D </span>의 다중 텍스처 단계<span lang=EN-US>(Stage)</span>를 지정하는 것과 비슷합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>glTexEnvi() </span>함수는 각 단계에 입력된 색상 혹은 알파 값이
기존의 값들과 연산을 지정하는 함수 입니다<span lang=EN-US>. </span>예를 들어<span lang=EN-US> 0</span>번째
단계에서 이 함수의 세 번째 인수에 <span lang=EN-US>GL_MODULATE</span>를 지정하면<span lang=EN-US>
glColor*() </span>함수로 지정된 색상과 텍스처 색상을 곱합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glTexEnvi</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_ENV</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_ENV_MODE</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_MODULATE</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>텍스처 색상만을 적용할 때는 세 번째 인수에 <span lang=EN-US>GL_DECAL</span>을 사용합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl06_tex2_multi.zip">gl06_tex2_multi.zip</a></span>의
<span lang=EN-US>CMcScene::Render() </span>에서 렌더링에서 멀티텍스처를 적용하는 함수 함수들의 호출 순서를 볼
수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>void</span><span
lang=EN-US> </span><span lang=EN-US style='color:blue'>CMcScene</span><span
lang=EN-US>::</span><span lang=EN-US style='color:#880000'>Render</span><span
lang=EN-US>()</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glActiveTextureARB</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE0_ARB</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glEnable</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glBindTexture</span><span lang=EN-US> (</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>,
m_nTexD);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glTexParameteri</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_MAG_FILTER</span><span lang=EN-US>,
</span><span lang=EN-US style='color:#A000A0'>GL_LINEAR</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glTexParameteri</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_WRAP_S</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_REPEAT</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glTexEnvi</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_ENV</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_ENV_MODE</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_MODULATE</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glActiveTextureARB</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE1_ARB</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glEnable</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glBindTexture</span><span lang=EN-US> (</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>,
m_nTexL);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glTexParameteri</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_MAG_FILTER</span><span lang=EN-US>,
</span><span lang=EN-US style='color:#A000A0'>GL_LINEAR</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glTexEnvi</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_ENV</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_ENV_MODE</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_MODULATE</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>DrawModel</span><span lang=EN-US>(&amp;mtWld);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glActiveTextureARB</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE0_ARB</span><span lang=EN-US>);&nbsp; </span><span
lang=EN-US style='color:#880000'>glBindTexture</span><span lang=EN-US> (</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glActiveTextureARB</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE1_ARB</span><span lang=EN-US>);&nbsp; </span><span
lang=EN-US style='color:#880000'>glBindTexture</span><span lang=EN-US> (</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>다중 텍스처도 각 단계에 대해서 <span lang=EN-US>glBindTexture
(GL_TEXTURE_2D, 0);</span>을 호출해서 다른 프로세스에 영향을 주지 않도록 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl06_tex2_multi.zip">gl06_tex2_multi.zip</a></span>의
색상과 <span lang=EN-US>glTexEnvi()</span>함수의 연산 방법을 바꾸면 다음과 같은 화면을 볼 수 있습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=191 height=144
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image020.jpg">&nbsp;<img border=0 width=192 height=144
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image021.jpg">&nbsp;<img border=0 width=193 height=144
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image022.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;</span>다중 텍스처<span lang=EN-US>: </span><span
lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl06_tex2_multi.zip">gl06_tex2_multi.zip</a>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MODULATE-
</span>색상<span lang=EN-US>(1,1,1,1), MODULATE- </span>색상<span lang=EN-US>(0,1,1,1),
ADD- </span>색상<span lang=EN-US>(0,1,1,1)&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:14.0pt'>11.1.7 2D Sprite</span></p>

<p class=MsoNormal>게임에서<span lang=EN-US> 2D </span>스프라이트는<span lang=EN-US>
UI(User Interface)</span>에서 많이 사용하므로 꼭 필요합니다<span lang=EN-US>. D3D</span>에서 우리는
이것을<span lang=EN-US> RHW</span>를 이용해서 구현해 보았습니다<span lang=EN-US>. OpenGL</span>은
비트맵을<span lang=EN-US> glRasterpos*() </span>함수로 화면 좌표와<span lang=EN-US> 1:1 </span>대응을
만들 수 있습니다<span lang=EN-US>. </span>그런데<span lang=EN-US> glRasterpos*() </span>함수는<span
lang=EN-US> ES</span>에서 지원이 안될 수도 있습니다<span lang=EN-US>. </span>따라서<span
lang=EN-US> 3D</span>에서 특정한 위치에 카메라를 고정하고 모델<span lang=EN-US>-</span>뷰 행렬과 투영 행렬을
조정해서 구현하거나 아니면 초기 상태로 설정하고 <span lang=EN-US>2D</span>를 구현 하는 것이 바람직합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>모델<span lang=EN-US>-</span>뷰 행렬과 투영 행렬은 설정을 안 하면<span
lang=EN-US>(</span>렌더링 머신의 디폴트 상태<span lang=EN-US>) </span>단위행렬이고 뷰 체적<span
lang=EN-US>(View-volume)</span>의 정점은<span lang=EN-US> [-1, 1] </span>범위에 있습니다<span
lang=EN-US>. UI</span>는 화면을 기준으로 구성되기 때문에 화면 좌표를 정규 변환 후의 좌표 값<span lang=EN-US>([-1,
1] </span>범위<span lang=EN-US>)</span>으로 변경해야 하며 이것을 공식으로 만들면 다음과 같이 됩니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><i>정규 좌표<span lang=EN-US> x =&nbsp; 2 * </span>화면 위치<span
lang=EN-US> x / </span>화면 너비<span lang=EN-US> - 1</span></i></p>

<p class=MsoNormal><i>정규 좌표<span lang=EN-US> y = -2 * </span>화면 위치<span
lang=EN-US> y / </span>화면 높이<span lang=EN-US> + 1</span></i></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>식의 검증을 위해 화면 위치를<span lang=EN-US> (0,0) </span>과<span
lang=EN-US> (</span>화면 너비<span lang=EN-US>, </span>화면 높이<span lang=EN-US>) </span>값을
입력하면 각각<span lang=EN-US> (-1, 1), (1, -1) </span>이 되어 식이 올바름을 알 수 있습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>정규 좌표와 더불어<span lang=EN-US> ST </span>좌표도 구해야 하는데<span
lang=EN-US> S, T</span>좌표는 입력된 이미지 영역을 이미지의 너비와 높이를 적용하면 바로 구해집니다<span
lang=EN-US>. </span>그런데<span lang=EN-US> OpenGL</span>은 좌 하단이<span lang=EN-US>
(0,0) </span>이고 우 상단이<span lang=EN-US> (1, 1)</span>입니다<span lang=EN-US>. </span>따라서
좌 하단의<span lang=EN-US> ST </span>값은 렌더링 이미지 영역의<span lang=EN-US> Left</span>와<span
lang=EN-US>, Bottom </span>을 이용해야 하며<span lang=EN-US> t </span>값은<span
lang=EN-US> &quot;1.0- t&quot; </span>로 계산이 되어야 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i>좌 하단<span lang=EN-US> s = (</span>렌더링 이미지 영역<span
lang=EN-US>).left/ </span>이미지 너비<span lang=EN-US>;</span></i></p>

<p class=MsoNormal><i>좌 하단<span lang=EN-US> t = 1.0 - (</span>렌더링 이미지 영역<span
lang=EN-US>).bottom/ </span>이미지 높이<span lang=EN-US>;</span></i></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>비슷하게 우 상단은<span lang=EN-US> right, top</span>을 이용합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i>우 상단<span lang=EN-US> s = (</span>렌더링 이미지 영역<span
lang=EN-US>).right/ </span>이미지 너비<span lang=EN-US>;</span></i></p>

<p class=MsoNormal><i>우 상단<span lang=EN-US> t = 1.0 - (</span>렌더링 이미지 영역<span
lang=EN-US>).top/ </span>이미지 높이<span lang=EN-US>;</span></i></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>gl07_sprite_texclass.zip</span>의 <span
lang=EN-US>CGLTexture::DrawPixel() </span>는<span lang=EN-US> 2D </span>스프라이트를 구현하는
함수입니다<span lang=EN-US>. </span>이 함수에서 다음의 코드는 위치와 렌더링 이미지의 영역을 조합해서<span
lang=EN-US> Left, Top, Right, Bottom</span>을 구하는 과정입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glGetFloatv</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_VIEWPORT</span><span lang=EN-US>, f);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>PosL =&nbsp; </span><span
lang=EN-US style='color:red'>2</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US> * vTrn.x/f[</span><span
lang=EN-US style='color:red'>2</span><span lang=EN-US>] - </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Left</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>PosT = -</span><span
lang=EN-US style='color:red'>2</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US> * vTrn.y/f[</span><span
lang=EN-US style='color:red'>3</span><span lang=EN-US>] + </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Top</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>PosR = PosL + </span><span
lang=EN-US style='color:red'>2</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US> * rcW * vScl.x/f[</span><span
lang=EN-US style='color:red'>2</span><span lang=EN-US>];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Right</span></p>

<p class=MsoNormal><span lang=EN-US>PosB = PosT - </span><span lang=EN-US
style='color:red'>2</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US> * rcH * vScl.y/f[</span><span
lang=EN-US style='color:red'>3</span><span lang=EN-US>];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Bottom</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'>텍스처 좌표<span lang=EN-US> S, T</span>는
렌더링 이미지가 주어질 때 계산 하도록 구현되어 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>if</span><span lang=EN-US>(rc)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcW=
</span><span lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>(rc-&gt;right
- rc-&gt;left);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcH=
</span><span lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>(rc-&gt;bottom-
rc-&gt;top);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st0.x
= rc-&gt;left/ImgW;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>좌 하단<span
lang=EN-US> S</span></span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st0.y
= </span><span lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span
lang=EN-US style='color:red'>0f</span><span lang=EN-US> - rc-&gt;bottom/ImgH;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>좌 하단<span
lang=EN-US> T</span></span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st1.x
= rc-&gt;right /ImgW;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>우 상단<span
lang=EN-US> S</span></span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st1.y
= </span><span lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span
lang=EN-US style='color:red'>0f</span><span lang=EN-US> - rc-&gt;top/ImgH;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>우 상단<span
lang=EN-US> T</span></span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>렌더링 이미지의<span lang=EN-US> 4 </span>점의 위치와<span lang=EN-US>
s, t</span>를 구하고 나서 정점을 그리기 전에 변환 행렬을 저장하고 전부 초기화<span lang=EN-US>(</span>단위 행렬<span
lang=EN-US>) </span>합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:green'>// </span><span style='color:green'>변환 행렬 저장</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>float</span><span lang=EN-US>&nbsp;&nbsp; mtPrj[</span><span
lang=EN-US style='color:red'>16</span><span lang=EN-US>]={</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>}; </span><span
lang=EN-US style='color:blue'>float</span><span lang=EN-US>&nbsp;&nbsp; mtViw[</span><span
lang=EN-US style='color:red'>16</span><span lang=EN-US>]={</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>};</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glGetFloatv</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_PROJECTION_MATRIX</span><span lang=EN-US>,
(</span><span lang=EN-US style='color:blue'>GLfloat</span><span lang=EN-US>*)mtPrj);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glGetFloatv</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_MODELVIEW_MATRIX</span><span lang=EN-US>, (</span><span
lang=EN-US style='color:blue'>GLfloat</span><span lang=EN-US>*)mtViw);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:green'>// </span><span style='color:green'>변환 행렬 전부 초기화</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glMatrixMode</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_PROJECTION</span><span lang=EN-US>);&nbsp; </span><span
lang=EN-US style='color:#880000'>glLoadIdentity</span><span lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glMatrixMode</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_MODELVIEW</span><span
lang=EN-US>);&nbsp;&nbsp; </span><span lang=EN-US style='color:#880000'>glLoadIdentity</span><span
lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>깊이 테스트를 비활성화로 설정해서 이전의 픽셀을 무조건 교체하도록 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glDisable</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_DEPTH_TEST</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>더불어 알파 테스트<span lang=EN-US>, </span>안개 효과<span lang=EN-US>, </span>조명
효과 등을 비활성화 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glDisable</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_ALPHA_TEST</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glDisable</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_LIGHTING</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glDisable</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_FOG</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>텍스처 이미지와 정점의 색상이 혼합 되도록 알파 블렌딩을 활성화 합니다<span lang=EN-US>. </span>이
때 블렌딩 옵션은 저장할 픽셀에 대해서는 <span lang=EN-US>GL_SRC_ALPHA</span>를 후면 버퍼에 저장된 픽셀에 대해서는
<span lang=EN-US>GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA</span>로 설정합니다<span
lang=EN-US>. </span>이 값은<span lang=EN-US> D3D</span>의 알파 블렌딩의 디폴트 블렌딩과 동일합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glEnable</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_BLEND</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glBlendFunc</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_SRC_ALPHA</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_ONE_MINUS_SRC_ALPHA</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>텍스처를 활성화 하고 필터링과 어드레싱을 지정한 다음<span lang=EN-US> 4 </span>정점을 그립니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glEnable</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_TEXTURE_2D</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glBegin</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_TRIANGLE_FAN</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glColor4f</span><span lang=EN-US>(dcolor.r,
dcolor.g, dcolor.b, dcolor.a);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glTexCoord2f</span><span lang=EN-US>(st0.x,
st0.y); </span><span lang=EN-US style='color:#880000'>glVertex3f</span><span
lang=EN-US>(PosL, PosB, </span><span lang=EN-US style='color:red'>0</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glEnd</span><span
lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>렌더링이 끝난 후에 깊이 테스트를 활성화 하고<span lang=EN-US>, </span>알파 블렌딩은 비활성화
하며 변환 행렬들은 <span lang=EN-US>glLoadMatrix*()</span>함수로 원래대로 되돌려 놓습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glEnable</span><span lang=EN-US>(</span><span lang=EN-US
style='color:#A000A0'>GL_DEPTH_TEST</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glDisable</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_BLEND</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glMatrixMode</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_PROJECTION</span><span lang=EN-US>);&nbsp; </span><span
lang=EN-US style='color:#880000'>glLoadMatrixf</span><span lang=EN-US>(mtPrj);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glMatrixMode</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_MODELVIEW</span><span
lang=EN-US>);&nbsp;&nbsp; </span><span lang=EN-US style='color:#880000'>glLoadMatrixf</span><span
lang=EN-US>(mtViw);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl07_sprite_texclass.zip">gl07_sprite_texclass.zip</a></span>은<span
lang=EN-US> 2D </span>스프라이트를 출력하는 예제입니다<span lang=EN-US>. </span>자주 사용하는 텍스처를 클래스로
만들고 <span lang=EN-US>IGLTexture </span>인터페이스로 추상화했습니다<span lang=EN-US>. CGLTexture
</span>클래스는 <span lang=EN-US>IGLTexture </span>인터페이스를 구현하는 클래스 입니다<span
lang=EN-US>. </span>이 클래스는<span lang=EN-US> &quot;</span>텍스처 이름<span
lang=EN-US>&quot;</span>을 만들고<span lang=EN-US>, 2D </span>스프라이트를 출력하는 <span
lang=EN-US>DrawPixel() </span>함수가 구현되어 있습니다<span lang=EN-US>. CGLTexture </span>클래스의
<span lang=EN-US>Create() </span>함수는 필터링이 지정 되지 않으면 텍스처를<span lang=EN-US> 2D </span>스프라이트로
그리는 용도로 간주하고 밉맵 생성을 안 하도록 작성되어 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>D3D </span>기반으로 구성된 프로그램과 호환을 위해서<span
lang=EN-US> IGLSprite </span>인터페이스도 간단하게 구현되어 있습니다<span lang=EN-US>. </span>실행하면
다음과 같은<span lang=EN-US> UI</span>를 볼 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image023.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;OpenGL</span>로 구현한<span lang=EN-US> 2D
Sprite: </span><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl07_sprite_texclass.zip">gl07_sprite_texclass.zip</a>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:14.0pt'>11.1.8 </span><span
style='font-size:14.0pt'>폰트</span></p>

<p class=MsoNormal>문자열 출력은 시스템 영역이어서<span lang=EN-US> OpenGL </span>자체로는 문자열을 출력할
수 없고 시스템의 지원을 받아서 출력해야 합니다<span lang=EN-US>. </span>윈도우 시스템의 경우<span
lang=EN-US> OpenGL</span>에 대해서<span lang=EN-US> GDI(Graphic Device Interface)</span>를
이용한 방법과 위글<span lang=EN-US>(wgl) </span>함수를 이용하는 방법<span lang=EN-US>, </span>두 가지
출력 방식이 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>GDI</span>를 이용한 방법을 먼저 보이고<span lang=EN-US>,
</span>다음으로 위글 함수를 이용한 방법을 소개하겠습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>GDI </span>방법은 다음 그림처럼 문자열을<span
lang=EN-US> GDI</span>에 출력합니다<span lang=EN-US>. </span>그 다음<span lang=EN-US>
GDI</span>의 메모리를 얻어와서 알파 블렌딩이 적용될 수 있도록<span lang=EN-US> 32</span>비트 픽셀로 만듭니다<span
lang=EN-US>. </span>마지막에는<span lang=EN-US> OpenGL </span>함수로 텍스처를 생성하고 이<span
lang=EN-US> 32</span>비트로 전환된 메모리를 바인딩 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=551 height=113
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image024.gif"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;GDI</span>를 이용한 출력 방법<span lang=EN-US>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>문자열을 출력하려면 폰트 객체가 필요합니다<span lang=EN-US>. Win API </span>함수<span
lang=EN-US> CreateFont(), CreateIndirectFont()</span>함수를 이용해서 폰트 객체를 생성합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>m_hFnt = </span><span lang=EN-US
style='color:#A000A0'>CreateFontIndirect</span><span lang=EN-US>(&amp;lFont);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>GDI</span>에 문자열을 출력해야 하는데 정확한<span
lang=EN-US> GDI</span>의 크기를 만들기 위해서 <span lang=EN-US>GetTextExtentPoint32() </span>와
<span lang=EN-US>GetTextMetrics() </span>함수를 사용해서 폰트를 적용한 문자열이 출력되는 폭을 계산합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>hDC = </span><span
lang=EN-US style='color:#880000'>GetDC</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>NULL</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>SelectObject</span><span lang=EN-US>(hDC, m_hFnt);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Parent window</span><span style='color:green'>의<span
lang=EN-US> DC</span>를 이용해 스트링의 정확한 픽셀 사이즈를 얻어 온다<span lang=EN-US>.</span></span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#A000A0'>GetTextExtentPoint32</span><span lang=EN-US>(hDC, m_sMsg,
iLen, &amp;sz);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>nImgW = sz.cx;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#A000A0'>GetTextMetrics</span><span lang=EN-US>(hDC, &amp;tm);</span></p>

<p class=MsoNormal><span lang=EN-US>nImgW -= tm.tmOverhang;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>DIB(Device Interface Bitmap) </span>을 정의하고 <span
lang=EN-US>CreateDIBSection() </span>함수로<span lang=EN-US> DIB Section</span>을 만듭니다<span
lang=EN-US>. </span>이 때 픽셀에 대한 주소를 얻기 위해 <span lang=EN-US>CreateDIBSection() </span>함수의
인수로 전달합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>BITMAPINFO</span><span
lang=EN-US> BmpInfo={</span><span lang=EN-US style='color:red'>0</span><span
lang=EN-US>};</span></p>

<p class=MsoNormal><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>BYTE</span><span lang=EN-US>*&nbsp;&nbsp; pPxlT = </span><span
lang=EN-US style='color:#A000A0'>NULL</span><span lang=EN-US>;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>HBITMAP</span><span
lang=EN-US> hBmpCur = ::</span><span lang=EN-US style='color:#880000'>CreateDIBSection</span><span
lang=EN-US>(hDC, &amp;BmpInfo, </span><span lang=EN-US style='color:#A000A0'>DIB_RGB_COLORS</span><span
lang=EN-US>, (</span><span lang=EN-US style='color:blue'>void</span><span
lang=EN-US> **)&amp;pPxlT, </span><span lang=EN-US style='color:red'>0</span><span
lang=EN-US>, </span><span lang=EN-US style='color:red'>0</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>앞에서 정의한<span lang=EN-US> HDC</span>를 그대로 사용하면 바탕화면에 문자열이 출력되고
또한 현재 화면의<span lang=EN-US> DC</span>를 가져오기가 불편함으로 <span lang=EN-US>CreateCompatibleDC()</span>함수로
현재의<span lang=EN-US> DC</span>와 동등한<span lang=EN-US> DC</span>를 만들고 이<span
lang=EN-US> DC</span>에<span lang=EN-US> DIB Section</span>을 연결합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>HDC</span><span lang=EN-US> hMemDC = ::</span><span
lang=EN-US style='color:#880000'>CreateCompatibleDC</span><span lang=EN-US>(hDC);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>HBITMAP</span><span
lang=EN-US> hBmpOld = (</span><span lang=EN-US style='color:blue'>HBITMAP</span><span
lang=EN-US>)::</span><span lang=EN-US style='color:#880000'>SelectObject</span><span
lang=EN-US>(hMemDC, hBmpCur);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>문자열을<span lang=EN-US> DC</span>에 출력하면 비트맵에 저장이 됩니다<span
lang=EN-US>. </span>배경을 투명으로 처리하고<span lang=EN-US> ExtTextOut() </span>함수로 문자열을
출력합니다<span lang=EN-US>. </span>출력이 완료되면 임시로 사용한<span lang=EN-US> MemDC </span>를
해제 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>SetBkMode</span><span lang=EN-US>(hMemDC, </span><span
lang=EN-US style='color:#A000A0'>TRANSPARENT</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>::</span><span
lang=EN-US style='color:#A000A0'>ExtTextOut</span><span lang=EN-US>(hMemDC, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>NULL</span><span lang=EN-US>, m_sMsg, iLen, </span><span
lang=EN-US style='color:#A000A0'>NULL</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>::</span><span
lang=EN-US style='color:#880000'>SelectObject</span><span lang=EN-US>(hMemDC,
hBmpOld); &nbsp;&nbsp;&nbsp;&nbsp; </span><span lang=EN-US style='color:green'>//
</span><span style='color:green'>이전 비트맵으로 복구</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>::DeleteDC</span><span
lang=EN-US>(hMemDC);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>임시<span
lang=EN-US> DC</span>를 제거</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>이렇게<span lang=EN-US> GDI</span>로 문자열 출력이 끝났습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal>다음으로 이<span lang=EN-US> GDI</span>에서 픽셀 주소에 얻어와 텍스처에 사용할 메모리에
복사를 합니다<span lang=EN-US>. GDI</span>의 픽셀 주소는 <span lang=EN-US>CreateDIBSection()
</span>함수의 인수로 사용했던 <span lang=EN-US>pPxlT </span>변수 입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>다음과 같이<span lang=EN-US> 32</span>비트 픽셀을 만듭니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>BYTE</span><span
lang=EN-US>*&nbsp;&nbsp; pPxl= </span><span lang=EN-US style='color:blue'>new</span><span
lang=EN-US> </span><span lang=EN-US style='color:blue'>BYTE</span><span
lang=EN-US>[</span><span lang=EN-US style='color:red'>4</span><span lang=EN-US>
* nImgW * nImgH];</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>DIB</span>는<span lang=EN-US> 24</span>비트 이므로<span
lang=EN-US> 32</span>비트로 복사를 할 때<span lang=EN-US> Red = 0, Green = 0, Blue = 0</span>이면
알파를 <span lang=EN-US>0</span>으로 설정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>INT</span><span lang=EN-US> n1 = (y*nImgW + x)* </span><span
lang=EN-US style='color:red'>3</span><span lang=EN-US>; </span><span
lang=EN-US style='color:blue'>INT</span><span lang=EN-US> n2 = (y*nImgW + x)* </span><span
lang=EN-US style='color:red'>4</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>BYTE</span><span lang=EN-US> R = pPxlT[n1 +</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>]; </span><span
lang=EN-US style='color:blue'>BYTE</span><span lang=EN-US> G = pPxlT[n1 +</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>]; </span><span
lang=EN-US style='color:blue'>BYTE</span><span lang=EN-US> B = pPxlT[n1 +</span><span
lang=EN-US style='color:red'>2</span><span lang=EN-US>];</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>pPxl[n2 +</span><span
lang=PT-BR style='color:red'>0</span><span lang=EN-US>] = R; pPxl[n2 +</span><span
lang=PT-BR style='color:red'>1</span><span lang=EN-US>] = G; pPxl[n2 +</span><span
lang=PT-BR style='color:red'>2</span><span lang=EN-US>] = B;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>pPxl[n2 +</span><span
lang=PT-BR style='color:red'>3</span><span lang=EN-US>] = </span><span
lang=PT-BR style='color:red'>0xFF</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=PT-BR
style='color:blue'>if</span><span lang=EN-US>(</span><span lang=PT-BR
style='color:red'>0</span><span lang=EN-US> == R &amp;&amp; </span><span
lang=PT-BR style='color:red'>0</span><span lang=EN-US> == G &amp;&amp; </span><span
lang=PT-BR style='color:red'>0</span><span lang=EN-US> == B)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPxl[n2
+</span><span lang=EN-US style='color:red'>3</span><span lang=EN-US>] = </span><span
lang=EN-US style='color:red'>0x0</span><span lang=EN-US>;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>픽셀 데이터<span lang=EN-US>, </span>너비<span lang=EN-US>, </span>높이<span
lang=EN-US>, 32 </span>비트에 대한 포맷<span lang=EN-US> GL_RGBA </span>가 만들어졌으므로 우리는<span
lang=EN-US> OpenGL</span>의 텍스처를 만들고 이 픽셀을 바인딩 할 수 있게 됩니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl08_font01_gdi1.zip">gl08_font01_gdi1.zip</a></span>은<span
lang=EN-US> GDI</span>에 문자열을 출력하고<span lang=EN-US>, </span>픽셀을 얻어와서 텍스처를 생성하는 예제입니다<span
lang=EN-US>. </span>이전의<span lang=EN-US> CGLTexture </span>클래스는 파일에서만 텍스처를 만들었으나
지금 같은 상황처럼 실시간으로 생성된 메모리에서도 텍스처를 만들어야 하므로 이를 처리할 수 있도록 약간의 수정을 가했습니다<span
lang=EN-US>. </span>어렵지 않은 내용이므로 설명을 생략하겠습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl08_font01_gdi2.zip">gl08_font01_gdi2.zip</a></span>는
<span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl08_font01_gdi1.zip">gl08_font01_gdi1.zip</a></span>을
수정해서<span lang=EN-US> GDI</span>를 이용한 폰트 클래스가 적용된 예제입니다<span lang=EN-US>. </span>이
둘을 실행하면 다음과 같은 화면을 볼 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image025.jpg">&nbsp;<img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image026.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;GDI</span>를 이용한 문자열 출력<span lang=EN-US>:
<a href="https://github.com/3dapi/et01_opengl/raw/master/gl08_font01_gdi1.zip">gl08_font01_gdi1.zip</a>, <a
href="https://github.com/3dapi/et01_opengl/raw/master/gl08_font01_gdi2.zip">gl08_font01_gdi2.zip</a>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>문자열 출력에 대한 위글 함수는 문자열에 대한<span lang=EN-US> 2</span>차원 비트맵을 만들고
출력하는 <span lang=EN-US>wglUseFontBitmapsW() </span>함수와<span lang=EN-US> 3</span>차원
정점 리스트를 만드는 <span lang=EN-US>wglUseFontOutlinesW() </span>함수<span lang=EN-US> 2</span>가지
있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>이들 함수들의 동작을 이해하기 위해서는<span lang=EN-US> OpenGL</span>의 디스플레이 목록<span
lang=EN-US>(Display List)</span>를 알아야 합니다<span lang=EN-US>. </span>디스플레이 목록은 그래픽
파이프에 대한 명령을 미리 처리하거나 또는 처리되는 과정을 저장해서 렌더링의 효율을 높이도록 하는 것입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>디스플레이 목록을 만드는 방법은 먼저<span lang=EN-US> glGenLists()</span>함수로<span
lang=EN-US> &quot;</span>디스플레이 이름<span lang=EN-US>&quot; </span>을 생성합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>GLuint</span><span
lang=EN-US>&nbsp; m_nGeo;</span></p>

<p class=MsoNormal><span lang=EN-US>m_nGeo = </span><span lang=EN-US
style='color:#880000'>glGenLists</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>다음으로 <span lang=EN-US>OpenGL</span>에 대한 명령어들을<span
lang=EN-US> glNewList()/glEnd() </span>함수 사이에 기록하면 디스플레이 이름에 명령어들이 바인딩 하게 됩니다<span
lang=EN-US>. </span>다음은 정점 렌더링을 디스플레이 목록에 바인딩하는 예입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glNewList</span><span lang=EN-US>(m_nGeo, </span><span
lang=EN-US style='color:#A000A0'>GL_COMPILE</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glBegin</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TRIANGLE_FAN</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glColor4f</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>(&nbsp; </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>,&nbsp; </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glColor4f</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>(&nbsp; </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>,&nbsp; </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>0f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glColor4f</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertex3f</span><span lang=EN-US>(&nbsp; </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>7f</span><span lang=EN-US>,&nbsp; </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>.</span><span lang=EN-US
style='color:red'>7f</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glEnd</span><span lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glEndList</span><span
lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>디스플레이 목록을 만들었으면<span lang=EN-US> glCallList() </span>또는<span
lang=EN-US> glCallLists() </span>함수를 호출하면<span lang=EN-US> glNewList() / glEndList()</span>에
등록된 명령어들을 실행합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glCallList</span><span
lang=EN-US>(m_nGeo);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>디스플레이 목록은<span lang=EN-US> glDeleteLists() </span>함수로 해제합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glDeleteLists</span><span
lang=EN-US>(m_nGeo, </span><span lang=EN-US style='color:red'>1</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>원칙적으로 모든<span lang=EN-US> OpenGL</span>의 명령어는 디스플레이 목록에 적용할 수
있지만 목록에 적용되지 않고 즉시 실행하거나 아니면 무한 루프에 빠지게 되는 상황에 대해서는<span lang=EN-US> OpenGL </span>도움말을
이용하기 바랍니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>앞의 코드에 대한 예는 <span lang=EN-US><a
href="https://github.com/3dapi/et01_opengl/raw/master/gl08_font03_displaylist.zip">gl08_font03_displaylist.zip</a></span>을 참고하기
바랍니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>폰트를 생성하고 <span lang=EN-US style='color:blue'>BOOL</span><span
lang=EN-US> </span><span lang=EN-US style='color:#880000'>wglUseFontBitmaps</span><span
lang=EN-US>(</span><span lang=EN-US style='color:blue'>HDC </span><span
lang=EN-US>hdc,</span><span lang=EN-US style='color:blue'>DWORD</span><span
lang=EN-US> first,</span><span lang=EN-US style='color:blue'>DWORD</span><span
lang=EN-US> count,</span><span lang=EN-US style='color:blue'>DWORD</span><span
lang=EN-US> listBase) </span>함수를 호출하면 이 함수는 해당<span lang=EN-US> DC</span>에서 설정한
폰트에 대해서<span lang=EN-US> first</span>에 해당하는 문자에서<span lang=EN-US> count</span>만큼
비트맵을 내부적으로 만듭니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>예를 들어 다음과 같은 코드가 있으면</p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>GLuint</span><span
lang=EN-US> sList = </span><span lang=EN-US style='color:#880000'>glGenLists</span><span
lang=EN-US>(</span><span lang=EN-US style='color:red'>96</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>HFONT</span><span lang=EN-US> hFont = </span><span
lang=EN-US style='color:#A000A0'>CreateFont</span><span lang=EN-US>(…);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>wglUseFontBitmaps</span><span
lang=EN-US>(hDC, </span><span lang=EN-US style='color:red'>32</span><span
lang=EN-US>, </span><span lang=EN-US style='color:red'>96</span><span
lang=EN-US>, sList);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>이 것은 <span lang=EN-US>ASCII </span><span lang=EN-US>32</span>번부터<span
lang=EN-US> 96</span>개의 문자에 대한 비트맵을 만들고 이것을 디스플레이 목록<span lang=EN-US> sList</span>에
바인딩하는 것을 의미합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>아스키 문자열에 대한 호출은 다음과 같이 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glPushAttrib</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_LIST_BIT</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glListBase</span><span lang=EN-US>(</span><span
lang=EN-US>sList</span><span lang=EN-US> - </span><span lang=EN-US
style='color:red'>32</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glCallLists</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#880000'>strlen</span><span lang=EN-US>(</span><span
lang=EN-US style='color:fuchsia'>&quot;ASCII </span><span style='color:fuchsia'>문자열<span
lang=EN-US>&quot;</span></span><span lang=EN-US>), </span><span lang=EN-US
style='color:#A000A0'>GL_UNSIGNED_BYTE</span><span lang=EN-US>, sList);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glPopAttrib</span><span
lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>그런데 한글은<span lang=EN-US> 2</span>바이트 문자입니다<span lang=EN-US>.
</span>따라서<span lang=EN-US> VC </span>프로젝트가<span lang=EN-US> Multi-Byte</span>로
설정되어 있는 경우에 <span lang=EN-US>wglUseFontBitmaps() </span>함수 대신 <span lang=EN-US>wglUseFontBitmapsW()</span>함수를
강제로 호출해야 합니다<span lang=EN-US>. </span>그리고 한가지 더 한글을 앞의 코드처럼 적용하면 디스플레이 목록이 거의<span
lang=EN-US> 2<sup>16</sup> </span>정도 크기를 가져야<span lang=EN-US> ASCII</span>의 예제처럼
사용할 수 있을 것입니다<span lang=EN-US>. </span>이것은 심각한 메모리 낭비가 아닐 수 없습니다<span
lang=EN-US>. </span>한글 문자열은 한꺼번에 다 만들어 사용하지 않고 한 문자당 하나의 디스플레이 목록을 만들어서 사용합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal>이를 위해 먼저 다음과 같이 <span lang=EN-US>Wide-Char </span>형 문자와 디스플레이
목록을 한 쌍으로 하는 구조체와 이 구조체에 대한 벡터 컨테이너를 준비합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>struct</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>TwcharLst</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>WCHAR</span><span lang=EN-US>&nbsp;&nbsp; c;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>GLuint</span><span lang=EN-US>&nbsp; l;</span></p>

<p class=MsoNormal><span lang=EN-US>};</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>vector</span><span
lang=EN-US>&lt;</span><span lang=EN-US style='color:blue'>TwcharLst</span><span
lang=EN-US>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vStr;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>입력된<span lang=EN-US> Multi-Byte </span>문자열을 한 문자씩<span
lang=EN-US> Wide-Char </span>형으로 변경하면서 벡터 컨테이너에 넣습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>char</span><span lang=EN-US>*&nbsp;&nbsp; s=sMsg;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>for</span><span lang=EN-US>(i=</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>; i&lt;</span><span lang=EN-US
style='color:#880000'>strlen</span><span lang=EN-US>(sMsg); ++i)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>WCHAR</span><span lang=EN-US>&nbsp;&nbsp; t=</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>if</span><span lang=EN-US>(*s&gt;</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>MultiByteToWideChar</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>CP_ACP</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>MB_PRECOMPOSED</span><span lang=EN-US>, s, -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, &amp;t, </span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>); ++s;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>else</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>MultiByteToWideChar</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>CP_ACP</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>MB_PRECOMPOSED</span><span lang=EN-US>, s, -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>, &amp;t, </span><span
lang=EN-US style='color:red'>2</span><span lang=EN-US>); s+=</span><span
lang=EN-US style='color:red'>2</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vStr.</span><span
lang=EN-US style='color:#880000'>push_back</span><span lang=EN-US>( </span><span
lang=EN-US style='color:blue'>TwcharLst</span><span lang=EN-US>(t,</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>));</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>앞에서<span lang=EN-US> Wide-Char </span>형으로 변경한 각각의 문자들에 대해서 디스플레이
목록을 만들고 <span lang=EN-US>wglUseFontBitmapsW() </span>함수로 바인딩 합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>for</span><span lang=EN-US>(i=</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>; i&lt;m_vStr.</span><span
lang=EN-US style='color:#880000'>size</span><span lang=EN-US>(); ++i)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>UINT</span><span lang=EN-US> uList = </span><span
lang=EN-US style='color:#880000'>glGenLists</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>wglUseFontBitmapsW</span><span lang=EN-US>(hDC,
m_vStr[i].c, </span><span lang=EN-US style='color:red'>1</span><span
lang=EN-US>, uList);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vStr[i].l
= uList;</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>문자열 출력은 벡터 컨테이너의 디스플레이 목록을 출력하는 것과 동일합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>for</span><span lang=EN-US>(</span><span lang=EN-US
style='color:blue'>INT</span><span lang=EN-US> i=</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>; i&lt;m_vStr.</span><span
lang=EN-US style='color:#880000'>size</span><span lang=EN-US>(); ++i)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glPushMatrix</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glPushAttrib</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_LIST_BIT</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glCallList</span><span lang=EN-US>
(m_vStr[i].l);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glPopAttrib</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glPopMatrix</span><span lang=EN-US>();</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>전체 코드는 <span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl08_font02_wgl_2d.zip">gl08_font02_wgl_2d.zip</a></span>을
참고하기 바랍니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image027.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt; wglUseFontBitmapsW() </span>함수를 이용한 비트맵
출력<span lang=EN-US>. <a href="https://github.com/3dapi/et01_opengl/raw/master/gl08_font02_wgl_2d.zip">gl08_font02_wgl_2d.zip</a>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>3</span>차원 문자열을 출력하는 방법은 <span lang=EN-US>wglUseFontOutlinesW()
</span>함수를 사용하는 것 이외에<span lang=EN-US> 2</span>차원 비트맵 폰트로 출력하는 것과 차이가 거의 없습니다<span
lang=EN-US>. </span>먼저 이전의 구조체를 변경해서 문자의 모양이 저장될 수 있도록 글리프<span lang=EN-US>(Glyph)
</span>변수를 추가합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>struct</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>TwcharLst</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>WCHAR</span><span lang=EN-US>&nbsp;&nbsp; c;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>GLuint</span><span lang=EN-US>&nbsp; l;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>GLYPHMETRICSFLOAT</span><span lang=EN-US> GMF;</span></p>

<p class=MsoNormal><span lang=EN-US>};</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>디스플레이 목록을 만들 때 <span lang=EN-US>wglUseFontOutlinesW() </span>함수를
사용합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>for</span><span lang=EN-US>(i=</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>; i&lt;m_vStr.</span><span
lang=EN-US style='color:#880000'>size</span><span lang=EN-US>(); ++i)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>UINT</span><span lang=EN-US> uList = </span><span
lang=EN-US style='color:#880000'>glGenLists</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>wglUseFontOutlinesW</span><span lang=EN-US>(hDC,
m_vStr[i].c, </span><span lang=EN-US style='color:red'>1</span><span
lang=EN-US>, uList</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
</span><span lang=EN-US style='color:red'>0</span><span lang=EN-US>.</span><span
lang=EN-US style='color:red'>0f</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>10</span><span lang=EN-US>.</span><span
lang=EN-US style='color:red'>0f</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
</span><span lang=EN-US style='color:#A000A0'>WGL_FONT_POLYGONS</span><span
lang=EN-US>, &amp;m_vStr[i].GMF);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vStr[i].l
= uList;</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>렌더링에서는 글리프 값을 이용해서 문자의 간격을 조정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>for</span><span lang=EN-US>(</span><span lang=EN-US
style='color:blue'>INT</span><span lang=EN-US> i=</span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>; i&lt;m_vStr.</span><span
lang=EN-US style='color:#880000'>size</span><span lang=EN-US>(); ++i)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glPushMatrix</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glPushAttrib</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_LIST_BIT</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glCallList</span><span lang=EN-US> (m_vStr[i].l);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glPopAttrib</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glPopMatrix</span><span lang=EN-US>();</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xPos
+= m_vStr[i].GMF.gmfCellIncX;</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl08_font02_wgl_3d.zip">gl08_font02_wgl_3d.zip</a></span>을
실행하면 다음과 같은<span lang=EN-US> 3D </span>문자열 출력을 볼 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image028.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;3</span>차원 문자열 출력<span lang=EN-US>: <a
href="https://github.com/3dapi/et01_opengl/raw/master/gl08_font02_wgl_3d.zip">gl08_font02_wgl_3d.zip</a>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:14.0pt'>11.1.9 </span><span
style='font-size:14.0pt'>카메라</span></p>

<p class=MsoNormal>우리는 지금까지 게임 프로그램에서 사용할<span lang=EN-US> OpenGL</span>의 내용을 살펴
보았습니다<span lang=EN-US>. </span>이외에<span lang=EN-US> OpenGL</span>의 내용을 상당히 많이 있지만
이 후의 기초적인 내용은 다음의<span lang=EN-US> OpenGL ES</span>에서 다시 추가해서 설명하겠습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>3D </span>게임 프로그램의 시작은 카메라 클래스를 만드는 일이며 카메라
클래스는 뷰 변환 행렬<span lang=EN-US>(View Transform Matrix)</span>과 투영 변환 행렬<span
lang=EN-US>(Projection Transform Matrix)</span>을 만드는 것입니다<span lang=EN-US>. </span>이것을
잘 구성해 놓으면<span lang=EN-US> ES</span>에서도 구조의 변함 없이 잘 동작하는 카메라가 될 수 있습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal>보통<span lang=EN-US> OpenGL</span>에서 카메라를 만들면 대부분의 사람들은 다음의 왼쪽
그림과 같이<span lang=EN-US> Y</span>축이 위를 향하고<span lang=EN-US> Z </span>축이 나오는 형태의 카메라를
만듭니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=273 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image029.jpg">&nbsp;<img border=0 width=272 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image030.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;Z</span>축이 나오는 방향<span lang=EN-US>, Y</span>축이
들어가는 방향<span lang=EN-US>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>그런데 이것을 크게 생각하지 않고 계속 게임 프로그램을 만드는 도중에 회전의 방향과 위치<span
lang=EN-US>, </span>그리고 삼각형의 은면 제거<span lang=EN-US>(Culling) </span>등을 적용할 때 혼란스러운
점이 많이 발생합니다<span lang=EN-US>. </span>물론 이것이 큰 문제는 아닙니다<span lang=EN-US>. </span>그런데
처음부터 오른쪽과 같은 형태의 카메라를 만들면 이런 문제들을 피할 수가 있습니다<span lang=EN-US>. </span>무엇보다도 마음에
드는 것은 수학 공식을 사용한 알고리즘 적용이 쉽고<span lang=EN-US>, </span>그림을 그려서 문제를 해결하려고 할 때 <span
lang=EN-US>Y</span>가 들어가는 방향이면 직관적입니다<span lang=EN-US>. </span>또한<span
lang=EN-US> 3DS MAX</span>의 화면과 일치해서 플러그인<span lang=EN-US>(Plugin) </span>만들 때도
유리합니다<span lang=EN-US>. </span>가장 큰 매력은<span lang=EN-US> D3D</span>에서 만든 데이터를<span
lang=EN-US> Y</span>와<span lang=EN-US> Z </span>교환 만으로<span lang=EN-US> OpenGL </span>시스템에
적용할 수 있다는 것입니다<span lang=EN-US>. </span>특히 에뮬레이터나 툴<span lang=EN-US>(Tool) </span>프로그램을<span
lang=EN-US> D3D</span>로 만들고 게임 시스템은<span lang=EN-US> OpenGL</span>을 만들 때 오른쪽과 같은
형태의 카메라는 여러모로 이점이 많다고 할 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>Y</span>축이 들어가는 방향의 카메라를 적용하기 위해서 <span
lang=EN-US>gluLookAt() </span>함수를 사용하려면 카메라의 입력 값<span lang=EN-US> Up </span>벡터를<span
lang=EN-US>&nbsp; (0, 0, 1) </span>방향으로 해야 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glMatrixMode</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_MODELVIEW</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>gluLookAt</span><span
lang=EN-US>(…, </span><span lang=EN-US style='color:red'>0</span><span
lang=EN-US>,</span><span lang=EN-US style='color:red'>0</span><span lang=EN-US>,</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>DXSDK </span>함수 <span lang=EN-US>D3DXMatrixLookAtRH()</span>을
이용할 때도 마지막<span lang=EN-US> Up </span>벡터의 방향을 다음과 같이<span lang=EN-US> (0,0,1)</span>로
합니다<span lang=EN-US>. </span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glMatrixMode</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_MODELVIEW</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>D3DXMatrixLookAtRH</span><span
lang=EN-US>(&amp;m_mtViw, …, &amp;</span><span lang=EN-US style='color:blue'>D3DXVECTOR3</span><span
lang=EN-US>(</span><span lang=EN-US style='color:red'>0</span><span lang=EN-US>,</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>,</span><span lang=EN-US
style='color:red'>1</span><span lang=EN-US>));</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glLoadMatrixf</span><span
lang=EN-US>((</span><span lang=EN-US style='color:blue'>FLOAT</span><span
lang=EN-US>*)&amp;m_mtViw);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>만야 카메라에<span lang=EN-US> gluPerspective() </span>함수 대신 <span
lang=EN-US>D3DXMatrixPerspectiveFovRH() </span>함수를 사용하려면 먼저 이 둘의 차이를 이해해야 합니다<span
lang=EN-US>. </span></p>

<p class=MsoNormal><span lang=EN-US>gluPerspective() </span>함수는 다음과 같은 행렬을 만들고 이것을
렌더링 머신의 투영 변환에 적용하는 함수입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><sub><img border=0 width=136 height=120
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image031.gif"></sub></span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>D3DXMatrixPerspectiveFovRH() </span>함수는 다음과
같은 행렬만 만들어 냅니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><sub><img border=0 width=138 height=120
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image032.gif"></sub></span></p>

<p class=MsoNormal><b><span lang=EN-US>&nbsp;</span></b></p>

<p class=MsoNormal>따라서 다음과 같이 투영 행렬을 만들고<span lang=EN-US> _33</span>과<span
lang=EN-US> _43</span>을<span lang=EN-US> OpenGL</span>에 맞게 수정한 다음<span
lang=EN-US> glLoadMatrixf()</span>함수를 호출해서 파이프라인에 연결합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>D3DXMATRIX</span><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp; m_mtPrj;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>투영 행렬</span></p>

<p class=MsoNormal><span lang=EN-US>…</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>D3DXMatrixPerspectiveFovRH</span><span
lang=PT-BR>(&amp;m_mtPrj</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
</span><span lang=PT-BR style='color:#A000A0'>D3DXToRadian</span><span
lang=PT-BR>(m_fFv), m_fAs, m_fNr, m_fFr);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=PT-BR>m_mtPrj._33 =&nbsp; (m_fNr+m_fFr)/(m_fNr</span><span
lang=PT-BR> </span><span lang=PT-BR>-m_fFr);</span></p>

<p class=MsoNormal><span lang=PT-BR>m_mtPrj._43 =&nbsp; </span><span
lang=PT-BR style='color:red'>2.0f </span><span lang=PT-BR>*</span><span
lang=PT-BR> </span><span lang=PT-BR>m_fNr</span><span lang=PT-BR> </span><span
lang=PT-BR>*</span><span lang=PT-BR> </span><span lang=PT-BR>m_fFr/(m_fNr-m_fFr);</span></p>

<p class=MsoNormal><span lang=PT-BR>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glMatrixMode</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_PROJECTION</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glLoadMatrixf</span><span
lang=EN-US>((</span><span lang=EN-US style='color:blue'>FLOAT</span><span
lang=EN-US>*)&amp;m_mtPrj);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>뷰 행렬<span lang=EN-US>, </span>투영 행렬에 대한 핵심 코드들을 살펴보았습니다<span
lang=EN-US>. </span>이제 카메라 클래스를 만들어 봅시다<span lang=EN-US>. </span>클래스 구성은 카메라 인터페이스를
담당하는<span lang=EN-US> ILcCam </span>클래스를 만들어 추상화 하고 구현은 <span lang=EN-US>CLcCam
</span>클래스를 두어 코드가 장차 게임 엔진에 포함 될 수 있도록 구조화합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>1 </span>인칭 카메라에서 전후방 이동에 대한<span
lang=EN-US> MoveForward() </span>함수를<span lang=EN-US>, </span>측면 이동은<span
lang=EN-US> MoveSideward() </span>함수를 그리고 회전에 대해서는<span lang=EN-US> Rotation() </span>함수를
인터페이스로 둡니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>아울러 렌더링에서 투영 변환과 뷰 변환을 렌더링 머신에 적용하는<span lang=EN-US>
TransformProj() </span>함수와<span lang=EN-US> TransformView() </span>함수도 인터페이스 함수로
구성합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>interface</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>ILcCam</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>virtual</span><span lang=EN-US> </span><span
lang=EN-US style='color:blue'>void</span><span lang=EN-US> </span><span
lang=EN-US style='color:#880000'>MoveForward</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US> fSpeed, </span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US> fD=</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>)=</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>virtual</span><span lang=EN-US> </span><span
lang=EN-US style='color:blue'>void</span><span lang=EN-US> </span><span
lang=EN-US style='color:#880000'>MoveSideward</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fSpeed)=</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>virtual</span><span lang=EN-US> </span><span
lang=EN-US style='color:blue'>void</span><span lang=EN-US> </span><span
lang=EN-US style='color:#880000'>Rotation</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US> fYaw, </span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US> fPitch, </span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US> fSpeed)=</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>virtual</span><span lang=EN-US> </span><span
lang=EN-US style='color:blue'>void</span><span lang=EN-US> </span><span
lang=EN-US style='color:#880000'>TransformProj</span><span lang=EN-US>()=</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>virtual</span><span lang=EN-US> </span><span
lang=EN-US style='color:blue'>void</span><span lang=EN-US> </span><span
lang=EN-US style='color:#880000'>TransformView</span><span lang=EN-US>()=</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>;</span></p>

<p class=MsoNormal><span lang=EN-US>};</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>이제<span lang=EN-US> ILcCam </span>클래스를 상속 받는 <span
lang=EN-US>CLcCam </span>클래스에서 앞의 함수들을 구현할 차례입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>먼저 전후방 이동에 대해서 구현해 봅시다<span lang=EN-US>. </span>전후방 이동은 그림처럼
카메라의 시선 방향으로 움직이는 것을 의미합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=361 height=211
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image033.gif"></span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>그런데 앞서서 우리는<span lang=EN-US> Y </span>축이 들어가는 방향으로 카메라를 구성한다고
했으므로 이전에 만들어 놓은 뷰 행렬의 뷰 행렬의<span lang=EN-US> Y</span>축에 해당하는<span lang=EN-US>
_12, _22, _32 </span>값을 시선 방향으로 만들 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i>시선 방향 벡터<span lang=EN-US> = D3DXVECTOR3(m_mtViw._12,
m_mtViw._22, m_mtViw._32)</span></i></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>하지만<span lang=EN-US> Y</span>축이 들어가는 방향으로 설정해도<span
lang=EN-US> Up </span>벡터가<span lang=EN-US> (0,0,1)</span>로 되어 있어 시선 방향은 여전히<span
lang=EN-US> _13, _23, _33 </span>값입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i>시선 방향 벡터<span lang=EN-US> = - D3DXVECTOR3(m_mtViw._13,
m_mtViw._23, m_mtViw._33)</span></i></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>이것은 종종 혼동하는 일들 중에 하나 입니다<span lang=EN-US>. </span>이런 것을 겪지 않으려면
원칙에 충실하는 것이 가장 좋습니다<span lang=EN-US>. </span>시선 방향이라는 것은<span lang=EN-US> Look </span>벡터에서
카메라의<span lang=EN-US> Eye</span>벡터를 빼고 이를 정규화한 벡터로 하면 문제는 없어 집니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i>시선 방향 벡터<span lang=EN-US> = Normalize(Look </span>벡터 <span
lang=EN-US>- Eye </span>벡터<span lang=EN-US>)</span></i></p>

<p class=MsoNormal><i><span lang=EN-US>&nbsp;</span></i></p>

<p class=MsoNormal>그리고 카메라의 전후방 이동은 행렬은 앞의 그림처럼 시선 방향 벡터에 적당한 이동 거리를 곱하고 이를<span
lang=EN-US> Look </span>벡터와<span lang=EN-US> Eye </span>벡터에 더하고 나서 뷰 행렬을 만들면 됩니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i><span lang=EN-US>Look </span></i><i>벡터<span lang=EN-US>
+= </span>시선 방향 벡터<span lang=EN-US> * Distance</span></i></p>

<p class=MsoNormal><i><span lang=EN-US>Eye </span></i><i>벡터<span lang=EN-US> +=
</span>시선 방향 벡터<span lang=EN-US> * Distance</span></i></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl09_camera02.zip">gl09_camera02.zip</a></span>의
<span lang=EN-US>CLcCam::MoveForward() </span>함수는 지금까지 설명한 방법을 적용해서 뷰 행렬을 구하는 함수
입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>void</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>CLcCam</span><span lang=EN-US>::</span><span lang=EN-US
style='color:#880000'>MoveForward</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US> </span><span
lang=EN-US>fSpeed</span><span lang=EN-US>, </span><span lang=EN-US
style='color:blue'>FLOAT</span><span lang=EN-US> </span><span lang=EN-US>fD</span><span
lang=EN-US>)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>D3DXVECTOR3</span><span lang=EN-US> </span><span
lang=EN-US>vcZ</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US>vcZ</span><span lang=EN-US> = </span><span lang=EN-US>m_vcLook</span><span
lang=EN-US> - </span><span lang=EN-US>m_vcEye</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXVec3Normalize</span><span lang=EN-US>(&amp;</span><span
lang=EN-US>vcZ</span><span lang=EN-US>, &amp;</span><span lang=EN-US>vcZ</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US>m_vcEye</span><span lang=EN-US>&nbsp; += </span><span lang=EN-US>vcZ</span><span
lang=EN-US> * </span><span lang=EN-US>fSpeed</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US>m_vcLook</span><span lang=EN-US> += </span><span lang=EN-US>vcZ</span><span
lang=EN-US> * </span><span lang=EN-US>fSpeed</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXMatrixLookAtRH</span><span lang=EN-US>(&amp;</span><span
lang=EN-US>m_mtViw</span><span lang=EN-US>, &amp;</span><span lang=EN-US>m_vcEye</span><span
lang=EN-US>, &amp;</span><span lang=EN-US>m_vcLook</span><span lang=EN-US>,
&amp;</span><span lang=EN-US>m_vcUp</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>측면 이동은 시선 방향 벡터와<span lang=EN-US> Up </span>벡터에 수직 방향으로 움직이는
것입니다<span lang=EN-US>. </span>따라서 앞에서처럼 시선 방향 벡터를 구하고 외적을 이용해서 시선 방향 벡터와<span
lang=EN-US> Up</span>벡터의 수직 벡터를 구합니다<span lang=EN-US>. </span>이 수직 벡터를 크기가<span
lang=EN-US> 1</span>인 단위벡터로 정규화하고 이동 거리를 곱한 다음<span lang=EN-US> Look </span>벡터<span
lang=EN-US>, Eye </span>벡터에 더하면 측면 이동을 구현하게 되는 것입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=539 height=261
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image034.gif"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;</span>측면 이동<span lang=EN-US>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i>시선 방향 벡터<span lang=EN-US> = Normalize(Look </span>벡터<span
lang=EN-US> - Eye </span>벡터<span lang=EN-US>)</span></i></p>

<p class=MsoNormal><i>측면 방향 벡터<span lang=EN-US> = Normalize( Cross(</span>시선 방향
벡터<span lang=EN-US>, Up </span>벡터<span lang=EN-US>) )</span></i></p>

<p class=MsoNormal><i><span lang=EN-US>Look </span></i><i>벡터<span lang=EN-US>
+= </span>측면 방향 벡터<span lang=EN-US> * Distance</span></i></p>

<p class=MsoNormal><i><span lang=EN-US>Eye </span></i><i>벡터<span lang=EN-US> +=
</span>측면 방향 벡터<span lang=EN-US> * Distance</span></i></p>

<p class=MsoNormal><i><span lang=EN-US>&nbsp;</span></i></p>

<p class=MsoNormal>이것은 <span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl09_camera02.zip">gl09_camera02.zip</a></span>의
<span lang=EN-US>CLcCam::MoveSideward() </span>함수에서 다음과 같이 구현되어 있습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>void</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>CLcCam</span><span lang=EN-US>::</span><span lang=EN-US
style='color:#880000'>MoveSideward</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US> fSpeed)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>D3DXVECTOR3</span><span lang=EN-US> vcZ =
m_vcLook - m_vcEye;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXVec3Normalize</span><span lang=EN-US>(&amp;vcZ,
&amp;vcZ);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>D3DXVECTOR3</span><span lang=EN-US>&nbsp;&nbsp;&nbsp; vcX;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXVec3Cross</span><span lang=EN-US>(&amp;vcX,
&amp;vcZ, &amp;m_vcUp);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXVec3Normalize</span><span lang=EN-US>(&amp;vcX,
&amp;vcX);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vcEye&nbsp;
+= vcX * fSpeed;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vcLook
+= vcX * fSpeed;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXMatrixLookAtRH</span><span lang=EN-US>(&amp;m_mtViw,
&amp;m_vcEye, &amp;m_vcLook, &amp;m_vcUp);</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>1</span>인칭 카메라의 회전은 그림처럼 회전에 대해서<span
lang=EN-US> Look </span>벡터<span lang=EN-US> - Eye </span>벡터를 각도 θ만큼 회전 시키고 이것을<span
lang=EN-US> Eye </span>벡터에 더해서 새로운<span lang=EN-US> Look </span>벡터를 만드는 것입니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=529 height=319
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image035.gif"></span></p>

<p class=MsoNormal>이것을 구현하려면<span lang=EN-US> Yaw</span>와<span lang=EN-US>
Pitch</span>를 각각 적용하는 것이 수월합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>Yaw</span>는 현재<span lang=EN-US> Z</span>축에 해당하므로<span
lang=EN-US> Yaw </span>값으로<span lang=EN-US> Z</span>축에 대한 회전 행렬을 만듭니다<span
lang=EN-US>. </span>새로운<span lang=EN-US> Look </span>벡터는 다음과 같이 구합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i>시선 벡터<span lang=EN-US> = Look </span>벡터<span lang=EN-US>
- Eye </span>벡터</i></p>

<p class=MsoNormal><i>회전 행렬<span lang=EN-US> = RotationMatrixZ(Yaw)</span></i></p>

<p class=MsoNormal><i>시선 벡터<span lang=EN-US>' = </span>시선 벡터<span lang=EN-US> *
</span>회전 행렬</i></p>

<p class=MsoNormal><i><span lang=EN-US>Up </span></i><i>벡터<span lang=EN-US>' =
Up </span>벡터 <span lang=EN-US>* </span>회전 행렬</i></p>

<p class=MsoNormal><i><span lang=EN-US>Look </span></i><i>벡터<span lang=EN-US>'
= Eye </span>벡터<span lang=EN-US> + </span>시선 벡터<span lang=EN-US>'</span></i></p>

<p class=MsoNormal><i><span lang=EN-US>&nbsp;</span></i></p>

<p class=MsoNormal><span lang=EN-US>Pitch</span>는 <span lang=EN-US>Yaw</span>와 처리하는
절차는 같지만 회전 행렬은 카메라의<span lang=EN-US> X</span>축에 대한 회전이므로 뷰 행렬의<span lang=EN-US>
_11, _21, _31</span>을 회전축으로 하고<span lang=EN-US> Pitch</span>만큼 회전한 행렬을 구해서 적용합니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i>시선 벡터<span lang=EN-US> = Look </span>벡터<span lang=EN-US>
- Eye </span>벡터</i></p>

<p class=MsoNormal><i>회전 행렬<span lang=EN-US> = RotationMatrixAxis(</span></i></p>

<p class=MsoNormal><i><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Axis(ViewMatrix._11,
ViewMatrix._21, ViewMatrix._31)</span></i></p>

<p class=MsoNormal><i><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
Pitch)</span></i></p>

<p class=MsoNormal><i>시선 벡터<span lang=EN-US>' = </span>시선 벡터<span lang=EN-US> *
</span>회전 행렬</i></p>

<p class=MsoNormal><i><span lang=EN-US>Up </span></i><i>벡터<span lang=EN-US>' =
Up </span>벡터 <span lang=EN-US>* </span>회전 행렬</i></p>

<p class=MsoNormal><i><span lang=EN-US>Look </span></i><i>벡터<span lang=EN-US>'
= Eye </span>벡터<span lang=EN-US> + </span>시선 벡터<span lang=EN-US>'</span></i></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl09_camera02.zip">gl09_camera02.zip</a></span>의
<span lang=EN-US>CLcCam::Rotation() </span>함수는 지금까지 설명한 방법을 적용해서 뷰 행렬을 구하는 함수 입니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>void</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>CLcCam</span><span lang=EN-US>::</span><span lang=EN-US
style='color:#880000'>Rotation</span><span lang=EN-US>(</span><span lang=EN-US
style='color:blue'>FLOAT</span><span lang=EN-US> fYaw, </span><span lang=EN-US
style='color:blue'>FLOAT</span><span lang=EN-US> fPitch, </span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US> fSpeed)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_fYaw&nbsp;&nbsp;
= &nbsp;</span><span lang=EN-US style='color:#A000A0'>D3DXToRadian</span><span
lang=EN-US>(fYaw&nbsp; * fSpeed);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_fPitch
=&nbsp; </span><span lang=EN-US style='color:#A000A0'>D3DXToRadian</span><span
lang=EN-US>(fPitch* fSpeed);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>D3DXMATRIX</span><span lang=EN-US> rot;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>D3DXVECTOR3</span><span lang=EN-US> vcZ;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>D3DXVECTOR3</span><span lang=EN-US> vcX;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Yaw</span><span style='color:green'>에 대한 회전</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vcZ
= m_vcLook - m_vcEye;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXMatrixRotationZ</span><span lang=EN-US>(&amp;rot,
m_fYaw);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXVec3TransformCoord</span><span lang=EN-US>(&amp;vcZ,
&amp;vcZ, &amp;rot);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXVec3TransformCoord</span><span lang=EN-US>(&amp;m_vcUp,
&amp;m_vcUp, &amp;rot);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vcLook
= vcZ + m_vcEye;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXMatrixLookAtRH</span><span lang=EN-US>(&amp;m_mtViw,
&amp;m_vcEye, &amp;m_vcLook, &amp;m_vcUp);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// Pitch</span><span style='color:green'>에 대한 회전</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vcZ
= m_vcLook - m_vcEye;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vcX
=</span><span lang=EN-US style='color:blue'>D3DXVECTOR3</span><span lang=EN-US>(m_mtViw._11,
m_mtViw._21, m_mtViw._31);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXMatrixRotationAxis</span><span lang=EN-US>(&amp;rot,
&amp;vcX, m_fPitch);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXVec3TransformCoord</span><span lang=EN-US>(&amp;vcZ,
&amp;vcZ, &amp;rot);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXVec3TransformCoord</span><span lang=EN-US>(&amp;m_vcUp,
&amp;m_vcUp, &amp;rot);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vcLook
= vcZ + m_vcEye;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>D3DXMatrixLookAtRH</span><span lang=EN-US>(&amp;m_mtViw,
&amp;m_vcEye, &amp;m_vcLook, &amp;m_vcUp);</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>카메라에서 가장 중요한 이동과 회전을 구현했습니다<span lang=EN-US>. </span>나머지<span
lang=EN-US> TramsformProj() </span>함수와<span lang=EN-US> TransformView() </span>함수로
뷰 행렬과 투영 행렬을 그래픽 파이프라인에 연결합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>void</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>CLcCam</span><span lang=EN-US>::</span><span lang=EN-US
style='color:#880000'>TransformProj</span><span lang=EN-US>()</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glViewport</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US style='color:blue'>INT</span><span lang=EN-US>(m_nScnW), </span><span
lang=EN-US style='color:blue'>INT</span><span lang=EN-US>(m_nScnH) );</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glMatrixMode</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_PROJECTION</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glLoadMatrixf</span><span lang=EN-US>((</span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>*)&amp;m_mtPrj);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>}</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>void</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>CLcCam</span><span lang=EN-US>::</span><span lang=EN-US
style='color:#880000'>TransformView</span><span lang=EN-US>()</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glMatrixMode</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_MODELVIEW</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glLoadMatrixf</span><span lang=EN-US>((</span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>*)&amp;m_mtViw);</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl09_camera02.zip">gl09_camera02.zip</a></span>을
실행하고<span lang=EN-US> 'W', 'S', 'A', 'D', 'UP', 'DOWN', 'LEFT', 'RIGHT'</span>을
누르면 이동과 회전을 볼 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=273 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image036.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;OpenGL 1</span>인칭 카메라<span lang=EN-US>:
<a href="https://github.com/3dapi/et01_opengl/raw/master/gl09_camera02.zip">gl09_camera02.zip</a>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:14.0pt'>11.1.10 </span><span
style='font-size:14.0pt'>정점 배열과 <span lang=EN-US>ASE</span></span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>11.1.10.1 </span><span
style='font-size:12.0pt'>정점 배열<span lang=EN-US>(Vertex Array) </span>사용</span></p>

<p class=MsoNormal><span lang=EN-US>D3D</span>는 정점 버퍼를 만들어서 장면을 만듭니다<span
lang=EN-US>. OpenGL</span>도 정점을 개별적으로 처리하는<span lang=EN-US> glVetex*() </span>함수
이외에 연속된 정점 배열<span lang=EN-US>(</span>버퍼<span lang=EN-US>)</span>를 처리하는 방법을 제공합니다<span
lang=EN-US>. </span>정점 배열<span lang=EN-US>(</span>버퍼<span lang=EN-US>)</span>를 사용하려면
<span lang=EN-US style='color:blue'>void</span><span lang=EN-US> </span><span
lang=EN-US style='color:#880000'>glEnableClientState</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>GLenum</span><span lang=EN-US> array) </span>함수를 호출해서
활성화해야 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>자주 사용되는<span lang=EN-US> array </span>인수의 종류는 다음과 같습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>GL_VERTEX_ARRAY: </span>정점의 위치 벡터를 저장한 배열을 활성화<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>GL_NORMAL_ARRAY: </span>정점의 법선 벡터를 저장한 배열을 활성화</p>

<p class=MsoNormal><span lang=EN-US>GL_COLOR_ARRAY: </span>정점의 색상<span
lang=EN-US>(Diffuse)</span>을 저장한 배열을 활성화<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>GL_TEXTURE_ARRAY: </span>정점의 텍스처 좌표를 저장한 배열을
활성화<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>만약 정점 배열의 각 성분 또는 서로 다른 배열을 조합해서 파이프라인에 위치<span lang=EN-US>
+ </span>법선 벡터<span lang=EN-US> + </span>색상<span lang=EN-US>(Diffuse) + </span>텍스처
좌표를 적용한다고 했을 때 이들 배열을 사용하기 위해서 다음과 같이 활성화 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glEnableClientState</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_VERTEX_ARRAY</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glEnableClientState</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_NORMAL_ARRAY</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glEnableClientState</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_COLOR_ARRAY</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glEnableClientState</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_COORD_ARRAY</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>사용이 끝나면 <span lang=EN-US>glDisableClientState() </span>함수를 호출해서
다른 프로세스에 영향을 주지 않도록 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glDisableClientState</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_VERTEX_ARRAY</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glDisableClientState</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_NORMAL_ARRAY</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:#880000'>glDisableClientState</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_COLOR_ARRAY</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glDisableClientState</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_TEXTURE_COORD_ARRAY</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>D3D</span>는<span lang=EN-US>
SetStreamSource() </span>함수를 이용해서 정점 스트림<span lang=EN-US>(</span>버퍼<span
lang=EN-US>)</span>을 파이프라인에 연결했으며 이 때 스트림은 각각 분리된 형태로도 입력이 된다고 했습니다<span
lang=EN-US>. OpenGL</span>도 정점의 배열이 하나로 합쳐진 형태 또는 분리된 형태 상관 없이 차원<span
lang=EN-US>, </span>성분의 형식<span lang=EN-US>, </span>하나의 배열 원소 크기<span
lang=EN-US>, </span>시작 주소를 정해서 배열을 사용합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>정점의 위치<span lang=EN-US>, </span>법선 벡터<span lang=EN-US>, </span>색상<span
lang=EN-US>, </span>텍스처 좌표로 구성된<span lang=EN-US> 4</span>개의 배열을 파이프라인에 연결하려면 다음과
같이 작성합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>FLOAT</span><span
lang=EN-US> Position_Array[] ;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>FLOAT</span><span
lang=EN-US> Normal_Array[] ;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>FLOAT</span><span
lang=EN-US> Diffuse_Array[] ;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>FLOAT</span><span
lang=EN-US> TexCoord_Array[] ;</span></p>

<p class=MsoNormal><span lang=EN-US>…</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glVertexPointer&nbsp;
</span><span lang=EN-US>(</span><span lang=EN-US style='color:red'>3</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_FLOAT</span><span
lang=EN-US>, </span><span lang=EN-US style='color:red'>0</span><span
lang=EN-US>, &nbsp;Position_Array);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glNormalPointer&nbsp;
</span><span lang=EN-US>(&nbsp;&nbsp; </span><span lang=EN-US style='color:
#A000A0'>GL_FLOAT</span><span lang=EN-US>, </span><span lang=EN-US
style='color:red'>0</span><span lang=EN-US>, </span><span lang=EN-US>Normal_Array</span><span
lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glColorPointer&nbsp;&nbsp;
</span><span lang=EN-US>(</span><span lang=EN-US style='color:red'>4</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_FLOAT</span><span
lang=EN-US>, </span><span lang=EN-US style='color:red'>0</span><span
lang=EN-US>, </span><span lang=EN-US>Diffuse_Array</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glTexCoordPointer</span><span
lang=EN-US>(</span><span lang=EN-US style='color:red'>2</span><span lang=EN-US>,
</span><span lang=EN-US style='color:#A000A0'>GL_FLOAT</span><span lang=EN-US>,
</span><span lang=EN-US style='color:red'>0</span><span lang=EN-US>, </span><span
lang=EN-US>TexCoord_Array</span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>gl*Pointer() </span>함수의 인수 첫 번째는 각 배열의 원소를 구성하는
성분의 수 입니다<span lang=EN-US>. </span>두 번째 인수는 이 성분의 데이터 형입니다<span lang=EN-US>. </span>세
번째 인수는 연속된 배열 원소들의<span lang=EN-US> Byte Offset</span>을 지정합니다<span lang=EN-US>.
</span>네 번째 인수는 시작 주소를 지정합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>여러분은 앞에서처럼 각각 분리된 형태보다 하나로 합쳐진 형태를 많이 사용할 것입니다<span
lang=EN-US>. </span>만약 하나의 정점에 위치<span lang=EN-US> + </span>법선<span lang=EN-US>
+ </span>색상<span lang=EN-US> + </span>텍스처 좌표로 구성된 정점 구조체를 사용하고 이것을 배열을 만들었을 때를 살펴
봅시다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>struct</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>VtxNDUV</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>&nbsp;&nbsp; p[</span><span
lang=EN-US style='color:red'>3</span><span lang=EN-US>];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>위치</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>&nbsp;&nbsp; n[</span><span
lang=EN-US style='color:red'>3</span><span lang=EN-US>];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>법선 벡터</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>&nbsp;&nbsp; d[</span><span
lang=EN-US style='color:red'>4</span><span lang=EN-US>];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>색상<span
lang=EN-US>(Diffuse)</span></span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>FLOAT</span><span lang=EN-US>&nbsp;&nbsp; s,t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>텍스처 좌표</span></p>

<p class=MsoNormal><span lang=EN-US>};</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>이 구조체에 대한 배열을<span lang=EN-US> new </span>연산자로 만들었을 때<span
lang=EN-US> gl*Pointer() </span>함수 사용에 세 번째 인수의<span lang=EN-US> Byte Offset </span>값을
정점 구조체의 크기를 전달하고 네 번째 인수는 다음과 같이 정점을<span lang=EN-US> char </span>형으로 캐스팅해서 사용하면
편리합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>INT</span><span
lang=EN-US> nVtxSize = </span><span lang=EN-US style='color:red'>100</span><span
lang=EN-US>;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:blue'>VtxNDUV</span><span
lang=EN-US>* pVtx = </span><span lang=EN-US style='color:blue'>new</span><span
lang=EN-US> </span><span lang=EN-US style='color:blue'>VtxNDUV</span><span
lang=EN-US>[nVtxSize];</span></p>

<p class=MsoNormal><span lang=PT-BR>…</span></p>

<p class=MsoNormal><span lang=PT-BR style='color:blue'>char</span><span
lang=PT-BR>* p = (</span><span lang=PT-BR style='color:blue'>char</span><span
lang=PT-BR>*)pVtx;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glVertexPointer&nbsp;
</span><span lang=EN-US>(</span><span lang=EN-US style='color:red'>3</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_FLOAT</span><span
lang=EN-US> , </span><span lang=EN-US style='color:blue'>sizeof</span><span
lang=EN-US>(</span><span lang=EN-US style='color:blue'>VtxNDUV</span><span
lang=EN-US>), p); p += </span><span lang=EN-US style='color:blue'>sizeof</span><span
lang=EN-US>(</span><span lang=EN-US style='color:blue'>FLOAT)</span><span
lang=EN-US>*</span><span lang=EN-US style='color:red'>3</span><span lang=EN-US>;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glNormalPointer&nbsp;
</span><span lang=EN-US>(&nbsp;&nbsp; </span><span lang=EN-US style='color:
#A000A0'>GL_FLOAT</span><span lang=EN-US> , </span><span lang=EN-US
style='color:blue'>sizeof</span><span lang=EN-US>(</span><span lang=EN-US
style='color:blue'>VtxNDUV</span><span lang=EN-US>), p); p += </span><span
lang=EN-US style='color:blue'>sizeof</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>FLOAT)</span><span lang=EN-US>*</span><span
lang=EN-US style='color:red'>3</span><span lang=EN-US>;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glColorPointer&nbsp;&nbsp;
</span><span lang=EN-US>(</span><span lang=EN-US style='color:red'>4</span><span
lang=EN-US>, </span><span lang=EN-US style='color:#A000A0'>GL_FLOAT</span><span
lang=EN-US> , </span><span lang=EN-US style='color:blue'>sizeof</span><span
lang=EN-US>(</span><span lang=EN-US style='color:blue'>VtxNDUV</span><span
lang=EN-US>), p); p += </span><span lang=EN-US style='color:blue'>sizeof</span><span
lang=EN-US>(</span><span lang=EN-US style='color:blue'>FLOAT)</span><span
lang=EN-US>*</span><span lang=EN-US style='color:red'>4</span><span lang=EN-US>;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glTexCoordPointer</span><span
lang=EN-US>(</span><span lang=EN-US style='color:red'>2</span><span lang=EN-US>,
</span><span lang=EN-US style='color:#A000A0'>GL_FLOAT</span><span lang=EN-US>
, </span><span lang=EN-US style='color:blue'>sizeof</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>VtxNDUV</span><span lang=EN-US>), p);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>이렇게 정점 배열을 파이프라인에 연결한 후에 마지막으로 정점 데이터에 대한 인덱스가 없을 때는<span
lang=EN-US> glDrawArrays() </span>함수를<span lang=EN-US>, </span>인덱스가 있으면<span
lang=EN-US> glDrawElements() </span>함수를 호출해서 렌더링을 명령합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glDrawArrays</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_&quot;MODE&quot;</span><span
lang=EN-US>, </span><span lang=EN-US style='color:red'>&quot;</span><span
style='color:red'>시작 인덱스<span lang=EN-US>&quot;</span></span><span lang=EN-US>,
&nbsp;</span><span lang=EN-US style='color:red'>&quot;</span><span
style='color:red'>정점 개수<span lang=EN-US>&quot;</span></span><span lang=EN-US>);</span></p>

<p class=MsoNormal><span lang=EN-US>…</span></p>

<p class=MsoNormal><span lang=EN-US style='color:#880000'>glDrawElements</span><span
lang=EN-US>(</span><span lang=EN-US style='color:#A000A0'>GL_&quot;MODE&quot;</span><span
lang=EN-US>,</span><span lang=EN-US style='color:red'> &quot;</span><span
style='color:red'>인덱스 수<span lang=EN-US>&quot;</span></span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_&quot;</span><span style='color:#A000A0'>인덱스
타입<span lang=EN-US>&quot;</span></span><span lang=EN-US>, &quot;</span>인덱스 시작 주소<span
lang=EN-US>&quot;);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>glDrawElements()</span>함수의 인수 중에 인덱스 수 계산은</p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><i>인덱스 수<span lang=EN-US> = </span>삼각형 수<span lang=EN-US> *
3 </span></i></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>로 계산 하고 인덱스 타입은<span lang=EN-US> UNSIGNED_SHORT </span>를 가장 많이
사용합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl10_01vertex_array.zip">gl10_01vertex_array.zip</a></span>의
<span lang=EN-US>CMcScene::Render()</span>를 보면 전체적인 정점 배열을 간단하게 사용하는 방법을 볼 수 있습니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>11.1.10.2 ASE</span></p>

<p class=MsoNormal><span lang=EN-US>Z</span>가 위를 가리키는 카메라를 만들고 정점 배열을 알고 있으면<span
lang=EN-US> ASE</span>를 적용하는 방법은 어려움이 없습니다<span lang=EN-US>. </span><span
lang=EN-US>D3D </span>기반에서<span lang=EN-US> ASE </span>데이터 해석을 할 때 우리는 행렬 원소의<span
lang=EN-US>, </span>좌표의 위치<span lang=EN-US>, </span>삼각형의 인덱스 위치 등을<span
lang=EN-US> D3D</span>에 맞게 수정했습니다<span lang=EN-US>. </span>어떤 부분이<span
lang=EN-US> D3D</span>에 맞게 고쳐야 할 지 처음 하는 분들에게는 많이 어려웠을 것입니다<span lang=EN-US>. </span>그런데
<span lang=EN-US>OpenGL</span>을 사용하면 이러한 문제는 없어집니다<span lang=EN-US>. </span>맥스<span
lang=EN-US>, OpenGL </span>모두 오른손 좌표계를 사용하고 카메라를 일치 시켰다면 데이터의 교환 없이 <span
lang=EN-US>ASE </span>파일을 그대로 읽어 오면 됩니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>주의할 것은 만약 여러분이<span lang=EN-US> DXSDK</span>에서 제공하는 수학 함수를 사용할
때 애니메이션 데이터 다루는 부분을 조심해야 하는데<span lang=EN-US> ASE Parsing</span>에서 사원수 누적은 <span
lang=EN-US>q3&nbsp;&nbsp; = q1 * q2; </span>이어야 합니다<span lang=EN-US>. </span>만약
여러분께서 오른손 좌표에 맞는 사원수를 만들고 회전을 누적하기 위해 사원수 곱셈을 했다면<span lang=EN-US> q3 = q2 * q1</span>이
되어야 할 것입니다<span lang=EN-US>. </span>그리고 애니메이션의 회전 행렬을 구할 때도 주의해야 합니다<span
lang=EN-US>. D3DXMatrixRotationQuaternion() </span>함수를 사용해서 사원수에서 행렬을 만들었으면 이 행렬을
전치<span lang=EN-US>(Transpose) </span>해야 애니메이션이 제대로 동작을 합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal>이 두 가지 점만 주의하면<span lang=EN-US> OpenGL</span>의<span
lang=EN-US> Character Animation</span>에서도<span lang=EN-US> D3DX SDK </span>수학함수를
활용할 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>D3D</span>에서 사용한<span lang=EN-US> ASE</span>를
거의 그대로 사용하려면 먼저 디바이스의<span lang=EN-US> DrawIndexedPrimitiveUP() </span>함수를 대신할<span
lang=EN-US> OpenGL </span>함수를 구성하는 것이 좋습니다<span lang=EN-US>. </span>다음은 <span
lang=EN-US>OpenGL</span>의 <span lang=EN-US>glEnableClientState(), gl*Pointer(),
glDrawElements()</span>를 사용해서 <span lang=EN-US>D3D</span>의<span lang=EN-US>
DrawIndexedPrimitiveUP() </span>일부분을 구현한 함수 입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>void</span><span lang=EN-US> </span><span lang=EN-US
style='color:#880000'>LcGL_DrawIndexedPrimitiveUP</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>INT</span><span lang=EN-US> mode</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
</span><span lang=EN-US style='color:blue'>INT</span><span lang=EN-US> nFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>삼각형 개수</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
</span><span lang=EN-US style='color:blue'>const</span><span lang=EN-US> </span><span
lang=EN-US style='color:blue'>void</span><span lang=EN-US> *indices&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>인덱스 버퍼</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
</span><span lang=EN-US style='color:blue'>DWORD</span><span lang=EN-US> dFVF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// FVF</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
</span><span lang=EN-US style='color:blue'>const</span><span lang=EN-US> </span><span
lang=EN-US style='color:blue'>void</span><span lang=EN-US>* pVtx&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>정점 버퍼</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
</span><span lang=EN-US style='color:blue'>INT</span><span lang=EN-US> dStride&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:green'>// </span><span style='color:green'>한 정점의 크기</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>if</span><span lang=EN-US>( </span><span
lang=EN-US style='color:#A000A0'>D3DFVF_XYZ</span><span lang=EN-US> &amp; dFVF)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glEnableClientState</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_VERTEX_ARRAY</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>if</span><span lang=EN-US>( </span><span
lang=EN-US style='color:#A000A0'>D3DFVF_DIFFUSE</span><span lang=EN-US> &amp; dFVF)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glEnableClientState</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_COLOR_ARRAY</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>if</span><span lang=EN-US>( </span><span
lang=EN-US style='color:#A000A0'>D3DFVF_TEX1</span><span lang=EN-US> &amp; dFVF)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glEnableClientState</span><span lang=EN-US>(</span><span
lang=EN-US style='color:#A000A0'>GL_TEXTURE_COORD_ARRAY</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>char</span><span lang=EN-US>* p = (</span><span
lang=EN-US style='color:blue'>char</span><span lang=EN-US>*)pVtx;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>if</span><span lang=EN-US>( </span><span
lang=EN-US style='color:#A000A0'>D3DFVF_XYZ</span><span lang=EN-US> &amp; dFVF)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glVertexPointer</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>3</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_FLOAT</span><span lang=EN-US>, dStride, p);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>if</span><span lang=EN-US>( (</span><span
lang=EN-US style='color:#A000A0'>D3DFVF_XYZ</span><span lang=EN-US>|</span><span
lang=EN-US style='color:#A000A0'>D3DFVF_DIFFUSE</span><span lang=EN-US>) == dFVF)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p
+= </span><span lang=EN-US style='color:blue'>sizeof</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>D3DXVECTOR3</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glColorPointer</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>4</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_FLOAT</span><span lang=EN-US>, dStride, p);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>else</span><span lang=EN-US> </span><span
lang=EN-US style='color:blue'>if</span><span lang=EN-US>( (</span><span
lang=EN-US style='color:#A000A0'>D3DFVF_XYZ</span><span lang=EN-US>|</span><span
lang=EN-US style='color:#A000A0'>D3DFVF_TEX1</span><span lang=EN-US>) == dFVF)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p
+= </span><span lang=EN-US style='color:blue'>sizeof</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>D3DXVECTOR3</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glTexCoordPointer</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>2</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_FLOAT</span><span lang=EN-US>, dStride, p);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>else</span><span lang=EN-US> </span><span
lang=EN-US style='color:blue'>if</span><span lang=EN-US>( (</span><span
lang=EN-US style='color:#A000A0'>D3DFVF_XYZ</span><span lang=EN-US>|</span><span
lang=EN-US style='color:#A000A0'>D3DFVF_DIFFUSE</span><span lang=EN-US>|</span><span
lang=EN-US style='color:#A000A0'>D3DFVF_TEX1</span><span lang=EN-US>) == dFVF)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p
+= </span><span lang=EN-US style='color:blue'>sizeof</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>D3DXVECTOR3</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glColorPointer</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>4</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_FLOAT</span><span lang=EN-US>, dStride, p);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p
+= </span><span lang=EN-US style='color:blue'>sizeof</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>D3DXCOLOR</span><span lang=EN-US>);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glTexCoordPointer</span><span lang=EN-US>(</span><span
lang=EN-US style='color:red'>2</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_FLOAT</span><span lang=EN-US>, dStride, p);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:#880000'>glDrawElements</span><span lang=EN-US>(mode, nFace
* </span><span lang=EN-US style='color:red'>3</span><span lang=EN-US>, </span><span
lang=EN-US style='color:#A000A0'>GL_UNSIGNED_SHORT</span><span lang=EN-US>, indices);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>ASE </span>파일을 <span lang=EN-US>Parsing </span>해서
렌더링을 구현했다 하더라도 우리는 여기서 한 발짝 더 나아가<span lang=EN-US> Parsing</span>한 데이터를 구조화해야 합니다<span
lang=EN-US>. </span>제일 먼저 처리해야 할 일은 데이터를 <span lang=EN-US>Binary </span>파일로 저장하는
것입니다<span lang=EN-US>. </span>다음으로<span lang=EN-US> X-file</span>의 예처럼 자원을 절약하기
위해 원본은 렌더링의 참조로 사용하고 월드 행렬과 애니메이션 데이터가 포함된 <span lang=EN-US>ASE Instance(Clone)</span>을
만드는 것입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=397 height=227
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image037.gif"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;ASE</span>를 활용하기 위한 클래스 다이어그램<span
lang=EN-US>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>그림의<span lang=EN-US> CLcAse</span>는<span lang=EN-US> ASE </span>파일을
해석하고<span lang=EN-US> Binary </span>파일을 저장하는 클래스 입니다<span lang=EN-US>. CLcAseInst</span>는
화면의 렌더링을 담당하며 월드 행렬과 애니메이션을 갱신하고<span lang=EN-US> Geometry</span>와<span
lang=EN-US> Material</span>은 <span lang=EN-US>CLcAse</span>의 객체를 참조하는 클래스 입니다<span
lang=EN-US>. CLcAseB</span>는<span lang=EN-US> Binary </span>파일을 해석하는 클래스입니다<span
lang=EN-US>. CLcAseBInst</span>는<span lang=EN-US> CLcAseInst</span>와 동일한 기능을 하며
렌더링에서<span lang=EN-US> CLcAseBInst </span>객체를 참조하는 클래스입니다<span lang=EN-US>. ASE</span>에
대한 뷰어에서는 위의<span lang=EN-US> 4</span>개가 전부 필요할 수도 있지만 게임에서는<span lang=EN-US>
CLcAseB</span>와<span lang=EN-US> CLcAseBInst</span>클래스<span lang=EN-US> 2</span>개만
필요합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>객체 속성을 설정하거나 가져오기 위한<span lang=EN-US> SetAttrib/GetAttrib() </span>함수가
있습니다<span lang=EN-US>. </span>예를 들어 <span lang=EN-US>CLcAseBInst::SetAttrib() </span>함수는
다음과 같이 문자열을 해석해서 값을 설정하고 있는데 이런 방법은 속성을 설정하는 것이 증가하면 자연히<span lang=EN-US>
if~else </span>구문이 증가하지만 모든 속성에 대해서<span lang=EN-US> Set/Get </span>함수를 만드는 것이 줄어들고
클래스를 구조화 하기에도 좋습니다<span lang=EN-US>. </span>현재는 비교를 위해 문자열을 사용했지만 상수<span
lang=EN-US>(enum) </span>값을 가지고 만들면 좀 더 속도에 이득이 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US
style='color:blue'>INT</span><span lang=EN-US> </span><span lang=EN-US
style='color:blue'>CLcAseBInst</span><span lang=EN-US>::</span><span
lang=EN-US style='color:#880000'>SetAttrib</span><span lang=EN-US>(</span><span
lang=EN-US style='color:blue'>char</span><span lang=EN-US>* sCmd, </span><span
lang=EN-US style='color:blue'>void</span><span lang=EN-US>* pData)</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>{</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>if</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US> ==</span><span
lang=EN-US style='color:#880000'>_stricmp</span><span lang=EN-US>(</span><span
lang=EN-US style='color:fuchsia'>&quot;Advance Time&quot;</span><span
lang=EN-US>, sCmd))</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>float</span><span lang=EN-US>&nbsp;&nbsp; fElapsedTime
= *((</span><span lang=EN-US style='color:blue'>float</span><span lang=EN-US>*)pData);</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dTimeCur
+= fElapsedTime;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>return</span><span lang=EN-US> </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>else</span><span lang=EN-US> </span><span
lang=EN-US style='color:blue'>if</span><span lang=EN-US>( </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US> ==</span><span
lang=EN-US style='color:#880000'>_stricmp</span><span lang=EN-US>(</span><span
lang=EN-US style='color:fuchsia'>&quot;World Matrix&quot;</span><span
lang=EN-US>, sCmd))</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>D3DXMATRIX</span><span lang=EN-US>* pTM = (</span><span
lang=EN-US style='color:blue'>D3DXMATRIX</span><span lang=EN-US>*)pData;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_mtWld =
*pTM;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>return</span><span lang=EN-US> </span><span
lang=EN-US style='color:red'>0</span><span lang=EN-US>;</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>…</span></p>

<p class=MsoNormal style='word-break:keep-all'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US style='color:blue'>return</span><span lang=EN-US> -</span><span
lang=EN-US style='color:red'>1</span><span lang=EN-US>;</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>전체 코드는 이전의<span lang=EN-US> ASE</span>의 확장이며 <span
lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl10_02ase.zip">gl10_02ase.zip</a></span>을 실행하면 다음 그림과 같이<span
lang=EN-US> 4</span>개의 캐릭터가 춤추고 있는 것을 볼 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=273 height=204
src="https://github.com/3dapi/et01_opengl/raw/master/et01_opengl.files/image038.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&lt;OpenGL</span>에서의<span lang=EN-US> ASE: </span><span
lang=EN-US><a href="https://github.com/3dapi/et01_opengl/raw/master/gl10_02ase.zip">gl10_02ase.zip</a></span><span lang=EN-US>&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>지금까지 게임에서 주로 사용되는 <span lang=EN-US>OpenGL </span>내용을 살펴 보았습니다<span
lang=EN-US>. </span>다음은<span lang=EN-US> OpenGL</span>사용할 때 꼭 기억해야 할 내용입니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>1. OpenGL</span>은 오른손 좌표계입니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>2. </span>행렬은 열 중심으로 처리되며 이로 인해 <span
lang=EN-US>DX SDK </span>함수를 사용할 수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>3. </span>월드 변환은 따로 존재하지 않고 모델<span
lang=EN-US> - </span>뷰 행렬 이 존재합니다<span lang=EN-US>. </span>월드 변환을 별도로 구현 하려면 행렬
스택을 이용합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>4. OpenGL</span>의 각도는<span lang=EN-US>
Degree</span>입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>5. </span>디스플레이 목록을 만들면 좀 떠 빠르게 처리됩니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>6. </span>문자열 출력은 따로 제공하지 않으며<span
lang=EN-US> Window System</span>의 경우<span lang=EN-US> wgl </span>함수를 이용합니다<span
lang=EN-US>. </span>이 때 문자열은 반드시 <span lang=EN-US>Wide-char</span>로 변환해야만 한글을 출력할
수 있습니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>7. </span>뷰 행렬은<span lang=EN-US>
D3DXMatrixLookAtRH() </span>함수로 만들 수 있습니다<span lang=EN-US>. Z </span>축이 위를 향하는 카메라를
만들고자 한다면<span lang=EN-US> Up </span>벡터는<span lang=EN-US> (0,0,1) </span>입니다<span
lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>8. OpenGL</span>은 투영 변환을 거치면 모든 뷰 체적 안의 정점은
전부<span lang=EN-US> [-1, 1] </span>범위 입니다<span lang=EN-US>. </span>따라서<span
lang=EN-US> D3D SDK D3DXMatrixPerspectiveFovRH() </span>함수로 투영 행렬을 만들고자 한다면 이 함수를
사용하고 나서<span lang=EN-US> _33, _43 </span>값을 다시 계산합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>9. D3D</span>처럼 정점 버퍼를 <span lang=EN-US>glDrawArrays(),
glDrawElements() </span>함수를 사용해서 그리는 방법이 존재합니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>10. </span>애니메이션에서 사원수 누적은<span lang=EN-US>
qn * … * q2 * q1</span>이며 <span lang=EN-US>D3D SDK </span>를 사용할 때는<span
lang=EN-US> q1 * q2 * qn</span>입니다<span lang=EN-US>.</span></p>

<p class=MsoNormal><span lang=EN-US>12. D3D SDK </span>함수 <span lang=EN-US>D3DXMatrixRotationQuaternion()
</span>를 사용해서 사원수에서 행렬을 만들면 이 행렬을 전치<span lang=EN-US>(Transpose)</span>해야 합니다<span
lang=EN-US>.</span></p>
<br>
<br>

</div>

<?php
	include '../base/lc_tail.php';
?>
